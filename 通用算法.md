## 1.排序算法  
  
### 1.1 冒泡排序
冒泡排序一般每次循环都将一个数放到确却的位置,每次都判断当前位置与后一个位置的大小关系，然后交换。可加入一个标识符表示当前这趟未发生交换，则直接跳出循环。  
  
  
关于复杂度为 O(n^2),冒泡排序是稳定的
```
public static void  bubbleSort(int[] array){
    for(int i=0;i<array.length-1;i++){
        boolean flag=true;
        for(int j=0;j<array.length-i-1;j++){
            if(array[j]>array[j+1]){
               swap(array,j,j+1);
               flag=false;
            }
        }
        if(flag)
            break;
    }
}
```
  
### 1.2 快速排序  
快排即每次选择一个基准元素，每一趟排序之后将比基准元素小的放在左边，大的放在右边。快速排序不是稳定的  


  
关于复杂度分析： 最坏情况下选择的基准元素是最小值或最大值，则为O(n^2),最好情况每次选择中间的值，排序后左右两边长度相差1，复杂度为O(log n),平均复杂度为 O(n*logn)

```
public static void quickSort(int[] arr,int left,int right){
    if(left<right){
        int pIndex=partition(arr,left,right);
        quickSort(arr,left,pIndex-1);
        quickSort(arr,pIndex+1,right);
    }
}
public static int partition(int[] array,int left,int right){
    int p=array[left],i=left,j=right;
    while(i<j){
        while(array[j]>=p && i<j) j--;
        while(array[i]<=p && i<j) i++;
        swap(array,i,j);
    }
    //将p放到i的位置
    swap(array,left,i);
    return i;
}
```
  
### 1.3 堆排序
数据机构中堆是一颗完全二叉树，除了叶子节点每个节点都有左右孩子。根据数组层次遍历存储，可以得出一个节点的父节点和左右孩子节点。  
堆排序就是首先将一个无序数组调整为一个大顶堆，每次循环，将堆顶也就是arr[0]的元素，换到末尾，然后调整堆，继续成为大顶堆。 

时间复杂度为O(n*logn),堆排序是不稳定的算法.虽然算法复杂度和快速排序时间一样，但是考虑系统实际操作，快速排序更快,这是因为局部性原理。     
  
在堆排中，每一个操作都是不利于程序的局部性原理的，每次元素间的比较、数的调整等，都不是相邻或者尽可能附近的元素间的比较(堆调整每次都从堆底拿元素到堆顶然后向下进行调整），那么这就需要不断地在磁盘和内存间换入换出数据。  
  
[来源](为什么在平均情况下快速排序比堆排序要优秀？ - fankeke的回答 - 知乎
https://www.zhihu.com/question/23873747/answer/344303909)

```
private static int getParentIndex(int child){
      
      return (child-1)/2;
}
private static int getLeftChildIndex(int parent){
      return 2 * parent + 1;
}
public static void adjustHeap(int[] arr,int parentIndex,int len){
    //左孩子序号，右孩子序号，两个孩子中值更大的序号
    int left=getLeftChildIndex(parentIndex),right,maxIndex;
    while(left<=len){
        right=left+1;
        //获取左孩子和右孩子更大的那个数
        maxIndex=left<len && arr[left]<arr[right] ? right:left;
        //父节点值小于孩子节点的值
        if(arr[parentIndex]<arr[maxIndex]){
            //交换值
            swap(arr,parentIndex,maxIndex);

            parentIndex=maxIndex;
            left=getLeftChildIndex(parentIndex);
        }
        else
            break;
    }
}
public static void HeapSort(int[] arr){
    int last=arr.length-1;
    for(int i=last;i>=0;i--){
        //先将无序数组变为大顶堆
        adjustHeap(arr,i,last);
    }
    while(last>=0){
        //将堆顶元素换到数组尾进行插入
        swap(arr,0,last--);
        //调整剩下数为大顶堆
        adjustHeap(arr,0,last);
    }
}
```

## 2. 二分查找  
二分查找主要是在一个有序数列中查找目标值,时间复杂度为 O(nlogn).二分查找主要分为三种情况：1、查找一个目标值所在数组中的位置 2、查找目标值在数组中最左边出现的位置 3、查找目标值在数组中最右边出现的位置。    

二分查找主要注意的事项是：
1. left和right的初始赋值
2. 跳出循环时left和right的值
3. 循环内部根据nums[mid]和目标值相比进行left和right的更新
  
### 2.1 寻找一个目标值
```
int binarySearch(int[] nums,int target){
    int left=0,right=nums.length-1;
    while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]==target){
            return mid;
        }else if(nums[mid]<target){
            left=mid+1;
        }else if(nums[mid]>target){
            right=mid-1;
        }
    }
    return -1;
}
```
### 2.2 寻找最左边界  
```
int binarySearchLeft(int[] nums,int target){
    int left=0,right=nums.length-1;
    while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]==target){
            right=mid-1;
        }else if(nums[mid]<target){
            left=mid+1;
        }else if(nums[mid]>target){
            right=mid-1;
        }
    }
    //寻找最左边界，因此对left进行检查
    if(left>=nums.length || nums[left]!=target){
        return -1;
    }
    return left;
}
```
  
### 2.3 寻找最右边界  
```
int binarySearchRight(int[] nums,int target){
    int left=0,right=nums.length-1;
    while(left<=right){
        int mid=left+(right-left)/2;
        if(nums[mid]==target){
            left=mid+1;
        }else if(nums[mid]<target){
            left=mid+1;
        }else if(nums[mid]>target){
            right=mid-1;
        }
    }
    //寻找最右边界，因此对right进行检查
    if(right<0 || nums[right]!=target){
        return -1;
    }
    return right;
}
```  
### 2.4 总结
三种情况都可以赋值:
```
left=0,right=nums.length-1;
```
循环条件都可以为 while(left<=right),即跳出循环条件时 left>right .三种不同情况下，跳出循环后做不同的处理。  
其中**寻找最左边界**和**最右边界** 差异性非常小，只需在 循环里更新 target==nums[mid] 时left和right的值，并且在跳出while后在判断一下即可，**寻找最左边界**
既然是寻找左边界，那就要减小右边边界也就是right的值，因此需要right=mid-1,然后判断的是left的值;**最右边界** 一样的思想
