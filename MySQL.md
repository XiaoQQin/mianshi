<!-- TOC -->
- [1. sql的join](#1-sql的join)  
- [2. 数据库存储引擎](#2-数据库存储引擎)  
  - [2.1 InnoDB和MyISAM](#21-InnoDB和MyISAM)  
- [3. 存储过程](#3-存储过程)  
- [4. MySQL的存储结构](#4-MySQL的存储结构)
  - [4.1 InnoDB行记录存储结构](#41-InnoDB行记录存储结构)  
  - [4.2 InnoDB数据页结构](#42-InnoDB数据页结构)
- [5. 数据库索引](#5-数据库索引)  
  - [5.1 索引的优缺点分析](#51-索引的优缺点分析)
  - [5.2 B树和B+树的区别](#51-B树和B+树的区别)
  - [5.3 索引为什么可以加快数据库的检索速度](#53-索引为什么可以加快数据库的检索速度)  
  - [5.4 索引的分类](#54-索引的分类)  
  - [5.5 最左匹配原则](#55-最左匹配原则)
- [6. 事务](#6-事务)  
  - [6.1 MySQL事务](#61-MySQL事务)  
  - [6.2 MySQL如何实现事务隔离的](#62-MySQL如何实现事务隔离的)
<!-- /TOC -->
## 1. sql的join  
下面都是最基本的join  

- 内连接(inner join)  
  内连接查询能将左表（表 A）和右表（表 B）中能关联起来的数据连接后返回。  
  ![内连接](https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/database/inner-join.png)  
  ```
  SELECT A.PK AS A_PK, B.PK AS B_PK,
     A.Value AS A_Value, B.Value AS B_Value
  FROM Table_A A
  INNER JOIN Table_B B
  ON A.PK = B.PK;
  ```
- 左连接(left join)  
  左连接查询会返回左表（表 A）中所有记录，不管右表（表 B）中有没有关联的数据。在右表中找到的关联数据列也会被一起返回。  
  ![左连接](https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/database/left-join.png)  
  ```
  SELECT A.PK AS A_PK, B.PK AS B_PK,
       A.Value AS A_Value, B.Value AS B_Value
  FROM Table_A A
  LEFT JOIN Table_B B
  ON A.PK = B.PK;
  ```
- 右连接(right join)  
  右连接查询会返回右表（表 B）中所有记录，不管左表（表 A）中有没有关联的数据。在左表中找到的关联数据列也会被一起返回。  
  ![右连接](https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/database/right-join.png)  
  ```
  SELECT A.PK AS A_PK, B.PK AS B_PK,
       A.Value AS A_Value, B.Value AS B_Value
  FROM Table_A A
  RIGHT JOIN Table_B B
  ON A.PK = B.PK;
  ```
- 全连接(full outer join)  
也被称作外连接，外连接查询能返回左右表里的所有记录，其中左右表里能关联起来的记录被连接后返回。  
![全连接](https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/database/full-outer-join.png)  
```
SELECT A.PK AS A_PK, B.PK AS B_PK,
       A.Value AS A_Value, B.Value AS B_Value
FROM Table_A A
FULL OUTER JOIN Table_B B
ON A.PK = B.PK;
```    
  
还有一些其他join，比如 **CROSS JOIN(笛卡尔集)**,**SELF JOIN**(返回表与自己连接后符合条件的记录，一般用在表里有一个字段是用主键作为外键的情况)等。  

## 2. 数据库存储引擎  
数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是存储引擎。我们主要关注两个MySQL存储引擎。  
  
### 2.1 InnoDB和MyISAM  
MySQL在5.5版本之前的数据库存储引擎默认为MyISAM,在5.5版本之后默认的存储引擎为InnoDB。最主要的是弄清楚这两个存储引擎之间的区别。  
  
两者的对比：  
  - **是否支持行锁**： MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。  
  - **是否支持事务**：MyISAM不支持事务，InnoDB支持事务
  - **是否支持外键**：MyISAM不支持外键，InnoDB支持
  - **是否支持MVCC**: 仅InnoDB支持MVCC,应对高并发事务, MVCC比单纯的加锁更高效。MVCC只有在事务的**读提交**和**可重复读**两个事务级别下工作。  
    
[JavaGuide/存储引擎](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
## 3. 存储过程
一段SQL语句的预编译集合，可以理解为存储过程是存储在数据库中的一系列SQL操作的批处理。    

**优点**  
  
  - 重复使用
  - 安全性
  - 因为是预先编译的,因此具有很高的性能  
    
**缺点**  
  - 存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。  
  - 存储过程的性能调校与撰写，受限于各种数据库系统。  
## 4. MySQL的存储结构  
因为MySQL的默认数据库存储引擎为InnoDB,所以只分析InnoDB的存储结构
### 4.1 InnoDB行记录存储结构  
我们平时以记录(可以简单的理解为数据表中的一行数据)为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为**行格式或者记录格式**。InnoDB如今有4中不同的**行格式**,分别是**Compact**、**Redundant**、**Dynamic**和**Compressed**，这四种行格式原理大致相同，只分析**Compact**。  
  
可在建表时设置``ROW_FORMAT=行格式名称``来设置表的行格式，也可使用``ALTER TABLE 表名 ROW_FORMAT=行格式名称``来修改行格式。      
InnoDB记录的格式如下所示:  
  
![compact行格式示意图.PNG](https://i.loli.net/2020/04/30/HtdLDr27o8qAfw9.png)  
  
一条完整的记录可以分为**记录的额外信息**和**记录的真实数据**。  
  
#### 记录的额外信息  
记录的额外信息是服务器为了描述这条记录不得不添加的一些信息，额外信息分为3部分:**变长字段长度列表**、**NULL值列表**和**记录头信息**。  

1.  **记录头信息**: 把所有变长类型的列的长度都存放在记录的开头部位形成一个列表，按照列的顺序**逆序存放**。变长字段长度列表中只存储值为**非NULL**的列内容占用的长度，**值为NULL 的列**的长度是不储存的。    
  
    比如表中一行记录中C1,C2,C4的长度为4,3,1 。则根据逆序存放则为 01 03 04 (十六进制)  
    
2.  **NULL值列表**: Compact把值为NULL的列统一管理起来，存储到NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列。  
      
     比如表中一行记录中c1,c3,c4为NULL，则NULL值列表为一个字节 0 0 0 0 0 1(c4) 1(c3) 0(c1),使用16进制为 06。      
     
  
![tc数据.png](https://i.loli.net/2020/04/30/Y89vgBykdxFcr41.png)  

   
   
3.  **记录头信息**:它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思，如下所示：  
  
  
![lutou.png](https://i.loli.net/2020/04/30/nR9Thg3viAmQwdp.png)
 
   
    
| 名称       | 大小(bit)         | 描述        |
|:-----------| :-------------:|:-------------:|
| 预留位1  | 1 | 没有使用 |
| 预留位2  | 1 | 没有使用 |
| deleta_mask  | 1 | 标记该记录是否被删除 |
| min_rec_mask | 1 | 标记该记录是否为B+树的非叶子节点中的最小记录 |
| n_owned  | 4 | 表示当前槽管理的记录数 |
| heap_no | 13 | 这个属性表示当前记录在本页中的位置  |
| record_type |3 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录 |
| next_record | 16 | 它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量 |  
  
next_record非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的next_record值为36，意味着从第一条记录的真实数据的地址处向后找36个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，**下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录**。而且规定 最小记录 的下一条记录就本页中主键值**最小的记录**，而本页中主键值最大的记录的下一条记录就是**最大记录** 。也就是页结构中中保存的**Infimum + Supremum**。  

```
这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗,
所以只是打个删除标记而已，而且这部分存储空间之后还可以重用，
也就是说之后如果有新记录插入到表中的话,可能把这些被删除的记录占用的存储空间覆盖掉。  
  
如果你想彻底的从磁盘上移除这些被删除的记录，可以使用这个语句：

`optimize table 表名;`

执行这个命令后服务器会重新规划表中记录的存储方式，把被标记为删除的记录从磁盘上移除。
```
#### 记录真实数据  
  
记录的真实数据除了我们插入的那些列的数据，MySQL会为每个记录默认的添加一些列，MySQL服务器会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 只有在表没有定义主键的时候才会为记录添加，相当于MySQL服务器帮我们来添加一个主键。    

 | 名称       | 是否必须        | 占用空间      |     描述      |
|:-----------| :-------------:|:-------------:|:-------------:|
| row_id	  | 否     |	6字节	| 行ID，唯一标识一条记录 |
| transaction_id | 是	| 6字节	| 事务ID |
| roll_pointer | 是	| 7字节	| 回滚指针 |  
  
### 4.2 InnoDB数据页结构  
  
页的本质就是一块16KB大小的存储空间，InnoDB为了不同的目的而把页分为不同的类型，其中用于存放记录的页也称为**数据页**。一个InnoDB数据页的存储空间被划分成了**7**个部分。  
  
![sj页结构.PNG](https://i.loli.net/2020/05/01/I4ESnXcFVpwqfNi.png)
 
  
| 名称       | 大小(字节)         | 描述        |
|:-----------| :-------------:|:-------------:|
| File Header | 固定的38字节 | 描述的就是页外的各种状态信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁 |
| Page Header | 固定的56个字节 | 专门存储页里的各种状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等 |
| Infimum + Supremum | 固定的26个字节 | 两个虚拟的伪记录，分别表示页中的最小和最大记录 |
| User Records | 大小不固定 | 真实存储我们插入的记录的部分 |
| Free Space | 大小不固定 | 页中尚未使用的部分 |
| Page Directory | 大小不固定 | 页中的记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。 |
| File Trailer | 固定的8个字节 | 用于检验页是否完整的部分 |  
  
在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话,就要去申请新的数据页。    
  
不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照**主键值由小到大的顺序**连接起来的。    
  
```
最小记录(伪记录,Infimum) -> 真实记录1 -> 真实记录2 -> ... -> 真实记录n -> 最大记录(伪记录,Supremum)
```  
#### 页目录  
记录按照主键值从小到大在数据页中形成一个单链表，当页面中记录过多时，为了查找更方便，不再从头到尾遍历，设计了页目录：    
   -  将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组  
   -  每个组的最后一条记录的头信息中的**n_owned**属性表示该组内共有几条记录  
   -  将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个**槽（英文名：Slot）**。这些地址偏移量都会被存储到靠近页的尾部的地方，页中存储地址偏移量的部分也被称为**Page Directory**。  
   -  对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在1-8条之间，剩下的分组中记录的条数范围只能在是4-8条之间。  

**如何将记录进行分组？**  
  
  
1)  初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。  
2)  之后每插入一跳记录都把这条记录放到最大记录所在的组，直到最大记录所在组中的记录数等于8个  
3)  在最大记录所在组中的记录数等于8个的时候再插入一条记录时，将最大记录所在组平均分裂成2个组，然后最大记录所在的组就剩下4条记录了，然后就可以把即将插入的那条记录放到该组中了。  
  
**页面中根据主键查找记录**  
  
1)  通过二分法确定该记录所在的槽。
2)  通过记录的next_record属性组成的链表遍历查找该槽中的各个记录。  
  
#### 数据页之间的结构  
每页都有  **File Header** 部分，它里面包含着本页的上一个和下一个数据页的页号，所以所有的数据页会组成一个**双链表**。  

强烈推荐:  
[ 我们都是小青蛙/InnoDB记录存储结构](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483670&idx=1&sn=751d84d0ce50d64934d636014abe2023&chksm=979688e4a0e101f2a51d1f06ec75e25c56f8936321ae43badc2fe9fc1257b4dc1c24223699de&scene=21#wechat_redirect)  
[ 我们都是小青蛙/InnoDB数据页结构](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483678&idx=1&sn=913780d42e7a81fd3f9b747da4fba8ec&chksm=979688eca0e101fa0913c3d2e6107dfa3a6c151a075c8d68ab3f44c7c364d9510f9e1179d94d&scene=21#wechat_redirect)  

## 5. 数据库索引  
索引是一种用于快速查询和检索数据的数据结构，比较常见的的索引结构为:B树，B+树和Hash。数据库可以通过索引加快数据的检索，索引就好比书中的目录一样，可以快速定位数据所在的位置。  

### 5.1 索引的优缺点分析  
**索引的优点**  
  - 可以大大加快数据的检索速度，这是最大的优点  
  - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。  
  - 随机IO变为顺序IO   
**索引的缺点**  
  
  - 创建索引和维护索引需要耗费时间:当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率  
  - 占用物理存储空间: 索引需要使用物理文件存储，也会耗费一定空间。  
  
### 5.2 B树和B+树的区别  
  
 - 1. B树的所有节点即存放key也存放data；而B+树只有叶子节点存放Key和data,其他非叶子节点都只存放Key  
 - 2. B树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与它相邻的叶子节点。  
 - 3. B+树的检索效率更加稳定，任何查找都是从根节点到叶子节点的过程。    
   
#### 关于Hash索引    
   
   
 **Hash索引不支持顺序查找和范围查找是它最大的缺点**。类似下列语句  
   
 ```
 SELECT * FROM tb1 WHERE id < 500;
 ```
 使用B+树索引的话,因为是有序的吗,在这种范围查询中，优势非常大，直接遍历比500小的叶子节点。而hash索引是根据hash算法来定位的，难不成还要把 1 - 499的数据，每个都进行一次hash计算来定位吗。  
 
### 5.3 索引为什么可以加快数据库的检索速度  

#### InnoDB的存储结构  
  
MySQL的基本存储结构是**页**,也就是记录都存在**页**里。  
  -  数据页之间组成一个**双向链表**  
  -  数据页里面的记录又会组成一个**单向链表**,每个数据页都会为存储在页里的记录生成一个**页目录** 
       -  通过**主键**在数据页里查询记录时可以在**页目录**里进行**二分查找**快速定位到对应的槽，            然后再遍历该槽对应分组中的记录即可快速找到指定的记录  
       -  以**非主键**为搜索条件，只能从最小记录开始依次遍历单链表中的每条记录。  
       
如果以如下```select * from user where username = 'Java3y'```没有使用任何优化的SQL语句查询,那么数据库会如下进行检索数据，在数据量很大的情况下会很慢：  
  
  - 定位到记录所在的页，需要遍历双向链表，找到所在的页。  
  - 从定位所在的页内查找相应的记录，不是根据主键查询，只能遍历所在页的单链表。 
#### InnoDB索引结构  
索引其实就是一个数据结构，这个结构里根据key(建立索引指定的列)已经将记录排好了序，可以很快的检索到记录对应的数据页(也就是上述中将**定位到记录所在的页**变得很快)。  
InnoDB中的索引是一棵B+树，一般说非叶子节点不存储数据(数据库中的记录),叶子节点存储数据。其实非叶子节点存储的我们可以称为**目录项记录**,所以说索引就像目录一样。    
上述[记录的数据格式](https://github.com/XiaoQQin/mianshi/edit/master/MySQL.md#InnoDB数据页结构)中有一个字段为 **record_type**:   
  
| 值       | 描述         |
|:-----------| :-------------:|
| 0 | 普通的用户记录 |
| 1 | 目录项记录 |
| 2 | 最小记录 |
| 3 | 最大记录 |  
  
目录项记录中 **record_type** 为  1，B+树叶子节点中 **record_type** 为 0 ,然后每个数据页中都有 **record_type** 为 2 和 3 的两条伪记录。B+树的索引如下所示  
![索引结构.PNG](https://i.loli.net/2020/05/01/DZpx2u1qX5fnyjk.png)    
上图可以看出B+树索引树叶子结构为:  
![索引叶子结构.PNG](https://i.loli.net/2020/05/01/vNYrbwCE1iDJyoj.png)  
那么我们查找一条记录流程如下：
- 确定**目录项记录**页：根据每页的目录项的主键值范围查到对应的**目录项页**，或许可以理解为查找B+树某个叶子节点的父节点    
- 通过**目录项记录** 页确定用户记录真实所在页，可以理解为查找到叶子节点  
- 在真实存储用户记录的页中定位到具体的记录。  
  
这样就可以回答为什么索引可以加快检索记录：  
InnoDB的存储结构为数据页，每页为16k,页与页之间会建立双向链表，我们遍历一条记录需要根据双向链，找到对应记录所在的数据页。在这过程中需要遍历每个经过数据页中的的记录，如果建立索引，由于建立的索引是根据列进行排序的，可以很快的定位到用户记录所在的数据页。  
  
强烈推荐：[ 我们都是小青蛙/MySQL的索引](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483701&idx=1&sn=bd229dd584f51ef4fe545d44ad8cdbf9&chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4&mpshare=1&scene=1&srcid=0409Tn66UYWSWvqEVlOpwGtR&key=6cd553e86912686a47d76f2d900b1b5b388c90b29708f016db3a6e1bcebe032220ba63626095c4298f32cda7d0d7bd11bded2365f05c32e522584dd149b98db0bb8549ef144cdca694665d31d35cfeef&ascene=0&uin=MzAzMjU4NDM3Nw%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.12.4+build(16E195)&version=12020810&nettype=WIFI&lang=zh_CN&fontScale=100&pass_ticket=YHEmqDDX8hHkj5FiSVpQvjYqIMBDHHDS2po4mfJe%2BqIXlqwJI%2Bg7aJUZq0%2BDwGJ0)  
[javaGuide/数据库索引](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.md)
### 5.4 索引的分类  

#### 聚簇索引  
聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。它有下面两个特点
1) 使用记录主键值的大小进行记录和页的排序，即**页与页之间和页内都是有序的**。这包括:  
   - 页内的记录是按照主键的大小顺序排成一个单向链表(页内)  
   - 存放用户记录的数据页是根据主键的大小排成一个双向链表(页与页之间)
   - 存放目录项记录的页根据主键的大小排成一个双向链表(页与页之间)
2) B+树的叶子节点存储的是完整的用户记录，所谓完整的用户记录，就是指这个记录中存储了所有列的值。  
  
这种聚簇索引并不需要我们在MySQL语句中显式的去创建，InnoDB存储引擎会**自动的为我们创建聚簇索引**(没有设置主键的话会自动添加一个主键)。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据。  

#### 二级索引  
不是依照主键建立的索引，思想和聚簇索引一样，将主键改变为建立索引的列，但是最主要的一点是**二级索引的叶子节点不是聚簇索引一样存储的是完整的记录数据，它存放的是主键，我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录**。  
  
这样做的原因是为了节省空间和性能，如果将完整的用户记录放到叶子节点是可以不用回表(也就是根据主键再查询一次)，但是极大的浪费空间，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍。
  
#### 联合索引  
以多个列的大小作为排序规则，建立索引。联合索引只会建立一个B+树，比如我们依照c1、c2建立联合索引，主键为c1。  
-  每条目录项记录都由c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序  
-  B+树叶子节点处的用户记录由c2、c3和主键c1列组成    
  
#### 覆盖索引  
如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一，这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作。  

如果一条SQL需要查询name，name字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。  

###  5.5 最左匹配原则  
  
最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。**where子句几个搜索条件顺序调换不影响查询结果，因为Mysql中有查询优化器，会自动优化查询顺序**。  
  
那么联合索引还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。  
如下图所示，根据(a,b)建立联合索引：  
![ab联合索引](https://img-blog.csdnimg.cn/20190401113210176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzQxOTE3MTA5,size_16,color_FFFFFF,t_70)  
  
到a的值是有顺序的,在a值相等的情况下，b值又是按顺序排列的，但是这种顺序是相对的。所以最左匹配原则遇上范围查询就会停止，剩下的字段都无法使用索引。例如a = 1 and b = 2 a,b字段都可以使用索引，因为在a值确定的情况下b是相对有序的，而a>1and b=2，a字段可以匹配上索引，但b值不可以，因为a的值是一个范围，在这个范围中b是无序的。  

[Mysql最左匹配原则](https://blog.csdn.net/sinat_41917109/article/details/88944290?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)

## 6. 事务
### 6.1 MySQL事务
事务是一个序列操作，其中的操作要么都执行，要么都不执行，它是一个不可分割的工作单位.事务有四大特性，被称作**ACID**。
#### A(Atomicity) 原子性
事务就是一系列的操作，要么全部都执行，要都不执行。Mysql中通过使用 **回滚日志(undo log)** 来实现原子性。  

回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志逻辑地将数据库中的修改撤销掉看，可以理解为，我们在事务中使用的每一条 INSERT 都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。

#### C(Consistency) 一致性
一致性是指事务将数据库从一种一致性状态变为下一种一致性状态。事务开始前和结束后，数据库的完整性约束没有被破坏。例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。

#### I(Isolation) 隔离性
隔离性要求每个读写事务对其他事务的操作对象能相互分离。MySQL支持4种隔离级别,随着事务隔离级别变得越来越严格，数据库对于并发执行事务的性能也逐渐下降。  
  
 1.  读未提交（READ UNCOMMITTED）
     任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交，会产生**脏读**。其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题。  
     事务A对某个数据进行修改，但是还未提交，如果事务B此时读取该数据就会读取到事务A中要修改的值，但是如果事务A要回滚，那么就会产生脏数据。  
     
 2.  读提交 （READ COMMITTED）
     读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。读提交就会产生**不可重复读问题**。不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的。流行的数据库都采用这种隔离级别，比如Oracle 和SQL Server,MySQL不是。  
     在同一事务中，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果。  
     
 3.  可重复读 （REPEATABLE READ）
     MySQL默认的隔离级别。而可重复读是指，事务不会读到其他事务对已有数据的修改，即使其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是会产生**幻读**问题。  
     
     **幻读**假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用
 4.  串行化 （SERIALIZABLE）
    串行化是4种事务隔离级别中隔离效果最好的，InnoDB 隐式地将全部的查询语句加上共享锁，解决了脏读、可重复读、幻读的问题,但是吞吐率最低。  
####  D(Durability) 持久性
一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。MySQL使用**重做日志(redo log)** 实现事务的持久性，重做日志由两部分组成，一是内存中  的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。    

当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上.也就是说日志文件是比数据文件更早写到磁盘中的。  

[《包你懂系列》一文讲清楚 MySQL 事务隔离级别和实现原理，开发人员必备知识点](https://juejin.im/post/5e81fcbae51d4546bb6f33e8#heading-15)       
   
   
[『浅入深出』MySQL 中事务的实现](https://draveness.me/mysql-transaction/)  
  
### 6.2 MySQL如何实现事务隔离的  
####   实现可重复读
为了实现可重复读，也就是事务在任意时刻读取的数据都是一样的，不会因为其他事务修改而发生变化。MySQL采用了**MVCC (多版本并发控制)** 的方式。  
数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取。  

####   并发写问题
并发写问题就是两个事务，对同一条数据做修改，数据最后应该是时间靠后的那个事务。更新之前要读数据，这个情况的读数据是当前版本的数据，也就是多版本中最新一次提交的那版。  
MySQL通过加行级锁来解决并发写问题。假设事务A执行 update 操作， update 的时候要对所修改的行加行锁，这个行锁会在提交之后才释放。而在事务A提交之前，事务B也想 update 这行数据，于是申请行锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会一直处于等待状态，直到事务A提交，事务B才能继续执行。  
    
    
加锁的过程要分有索引和无索引两种情况。有索引的情况， MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。如果无索引,MySQL 会为这张表中所有行加行锁,在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行。  
#### 解决幻读  
解决幻读用的也是锁，叫做间隙锁，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。  
  
[《包你懂系列》一文讲清楚 MySQL 事务隔离级别和实现原理，开发人员必备知识点](https://juejin.im/post/5e81fcbae51d4546bb6f33e8#heading-15)

## 7. MySQL锁  
### 7.1 表锁和行锁  
从锁的粒度，可以划分为表锁和行锁：  
  
-  **表锁**：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低  
-  **行锁**: 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高  
不同的数据库存储引擎支持的锁粒度是不一样的  
  
- **InnoDB支持行锁和表锁**  
- **MyISAM只支持表锁**  
InnoDB只有通过索引条件检索数据时才会使用行锁，也就是说**InnoDB的行锁是基于索引的**  
### 7.2 行锁
