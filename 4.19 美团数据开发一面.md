#   1. Integer对象的==和equals，Integer缓冲池
关于Integer这个类，它是重写了equals方法的，比较的是两个Intger对象的值是否相同。  
如果将一个整型直接赋值给一个Integer对象，会发生自动装箱，比如： Integer a=200。它相当于 Integer a=Integer.valueOf(200).下面valueOf方法的源代码：  
```
public static Integer valueOf(int i) {  
  assert IntegerCache.high >= 127;  
  if (i >= IntegerCache.low && i <= IntegerCache.high)  
    return IntegerCache.cache[i + (-IntegerCache.low)];  
  return new Integer(i);  
}
```
可以看到有一个IntegerCache，默认IntegerCache.low 是-127，Integer.high是128，如果参数中的i在这个范围之内，则返回一个数组中的内容，
如果不在这个范围，则new一个新的Integer对象并返回。  

两个自动装箱的变量，但是装箱传递的值大于127，比如 Integer a=200,b=200; a==b; 那么a==b 就会返回false。因为值不在-128-127这个返回，如果在这个范围那么返回的是true.
自动拆箱是一个整型和一个Integer对象进行比较如： int a=200;Integer b=200; a==b; 那么b就会自动拆箱调用**intValue**方法，得到对象里的值再进行比较。  
当一个整型传入Integer对象的equals方法里，也会发生自动装箱，java会自动将这个值打包装箱为Integer类。  

因此可以得出：  
 1). Integer类里的equals方法是重写过的，比较的是值  
 2). 发生自动装箱，那么要根据传入的值进行判断，如果不在[-128,127]这个范围，就会new一个Integer对象.  

[java基础中Integer值用==和equals判断相等问题解析](https://blog.csdn.net/w112736112736/article/details/77986283)
    
#   2. volatile和synorized关键字
在Java虚拟机规范中试图定义一种Java内存模型(**JMM**),来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。  
Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。  
如果一个程序想要并发的执行，那么必须保证原子性、可见性、一致性。   
  
  
**原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。  
可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。  
有序性：有序性：即程序执行的顺序按照代码的先后顺序执行**  

加入volatile关键字时，会多出一个lock前缀指令：
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  
   1)  它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成  
   2)  它会强制将对缓存的修改操作立即写入内存  
   3)  如果是写操作，它会导致其他CPU中对应的缓存行无效。    
   
synchronized则会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。
关于volatile和synchronized的区别：
1)  volatile本质是在告诉当前线程中的工作内存中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2)  volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3)  volatilebn能实现变量的修改可见性和有序性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性,有序性
4)  volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞

[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)
#   3. mysql 事务access.id
#   4. 关于mysql索引，是否命中索引
