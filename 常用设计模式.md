## 1. 单例模式  
有**懒汉式和饿汉式**两种单例方式。饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，
而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。下面推荐两种线程安全的写法。  
  
### 1.1 懒汉式双重验证写法  
```
public class Singleton {
    private static Singleton instance=null;
    private Singleton(){}

    public static Singleton getInstance(){
        if(instance==null){
            synchronized (Singleton.class){
                if(instance==null){
                    instance=new Singleton();
                }
            }
        }
        return instance;
    }
}
```
### 1.2 饿汉式
饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的
```
public class Singleton1 {
    private Singleton1() {}
    private static final Singleton1 single = new Singleton1();
    //静态工厂方法 
    public static Singleton1 getInstance() {
        return single;
    }
}
```
  
[Java实现单例模式](https://blog.csdn.net/u011595939/article/details/79972371#3%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81)  
[Java设计模式—单例设计模式(Singleton Pattern)完全解析](https://blog.csdn.net/dmk877/article/details/50311791)
## 2. 工厂模式  
提供一个工厂方法，传入指定的参数得到想要的对象,有**简单工厂模式、工厂方法模式、抽象工厂模式**。  
  
## 2.1 简单工厂模式
```
//水果抽象类
public abstract class Fruit {
}
//苹果类
public class Apple extends Fruit {
    public Apple(){

    }
}
//橘子类
public class Orange extends Fruit {
    public Orange(){}
}
```
简单工厂模式就是有一个类为工厂类，里面有一个方法可以创造水果  
```
public class FruitFactory {

    public  FruitFactory(){}
    public Fruit create(String type){
        switch (type){
            case "Apple":return  new Apple();
            case "Orange":return  new Orange();
            default: break;
        }
        return null;
    }
}
```
客户类，调用工厂类FruitFactory的create即可
缺点：  
  
- 生产的产品过多，此模式会让工厂类过于庞大  
- 要生产新产品时，要在工厂类中添加新的分类  

### 2.2 工厂方法模式 
每个产品都有自己的工厂，比如苹果有自己的苹果厂，橘子有专门的橘子工厂
```
//工厂类接口
public interface FruitFactory {
    Fruit create();
}
//苹果工厂
public class AppleFactory  implements FruitFactory{
    @Override
    public Apple create() {
        return new Apple();
    }
}
//橘子工厂  
public class OrangeFactory implements FruitFactory {
    @Override
    public Orange create() {
        return new Orange();
    }
}
//客户类
public class Customer {
    public static void main(String[] args){
        //生产苹果
        AppleFactory appleFactory=new AppleFactory();
        Apple apple=appleFactory.create();
        
        //生产橘子
        OrangeFactory orangeFactory=new OrangeFactory();
        Orange orange=orangeFactory.create();
    }
}
}
```
### 2.3 抽象工厂模式  
