## 1. RDD的基本原理  
RDD（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个不可变、可分区、里面的元素可并行计算的集合。  
RDD具有数据流模型的特点：自动容错、位置感知性调度和可伸缩性。它并不是真正存储数据的结构，而是一种抽象的概念,我们可以认为 RDD 就是一个代理，
我们操作这个代理就像操作本地集合一样，不需去关心任务调度、容错等问题。  
  
### RDD的属性
RDD具有属性，它的属性用来描述当前数据集的状态，我们可以简单的理解为RDD里的包括什么  
  
- **一组分片(Partition)**: 即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。
用户可以在创建RDD 的时候指定RDD的分片个数，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Cores 的数目。  
  
- **一个计算每个分区的函数**：。Spark中RDD的计算是以分片为单位的，每个RDD都会实现compute函数以达到这个目的。
compute函数会对迭代器进行复合，不需要保存每次计算的结果  
  

- **一个Partitioner**：即RDD的分片函数。当前Spark中实现了两种类型的分片函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。
只有对于于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。
Partitioner函数不但决定了RDD本身的分片数量，也决定了parent RDD Shuffle输出时的分片数量。  
  
- **RDD之间的依赖关系**：RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系。
在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算  
  
- **一个列表，存储存取每个Partition的优先位置（preferred location）**。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。
按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。
  
## 2. spark的部署方式  
  
1) local本地模式 :常用于本地开发测试，如在eclipse，idea中写程序测试等,本地还分为local单线程和local-cluster多线程。  

2) standalone模式: 集群模式,Spark自带的一个资源调度框架，支持完全分布式。  
3) spark on yarn ：集群模式，运行在yarn资源管理器框架之上，由yarn负责资源管理，Spark负责任务调度和计算 
4) spark on mesos： 运行在mesos资源管理器框架之上，由mesos负责资源管理，Spark负责任务调度和计算
