#   1. Integer对象的==和equals，Integer缓冲池
关于Integer这个类，它是重写了equals方法的，比较的是两个Intger对象的值是否相同。  
如果将一个整型直接赋值给一个Integer对象，会发生自动装箱，比如： Integer a=200。它相当于 Integer a=Integer.valueOf(200).下面valueOf方法的源代码：  
```
public static Integer valueOf(int i) {  
  assert IntegerCache.high >= 127;  
  if (i >= IntegerCache.low && i <= IntegerCache.high)  
    return IntegerCache.cache[i + (-IntegerCache.low)];  
  return new Integer(i);  
}
```
可以看到有一个IntegerCache，默认IntegerCache.low 是-127，Integer.high是128，如果参数中的i在这个范围之内，则返回一个数组中的内容，
如果不在这个范围，则new一个新的Integer对象并返回。  

两个自动装箱的变量，但是装箱传递的值大于127，比如 Integer a=200,b=200; a==b; 那么a==b 就会返回false。因为值不在-128-127这个返回，如果在这个范围那么返回的是true.
自动拆箱是一个整型和一个Integer对象进行比较如： int a=200;Integer b=200; a==b; 那么b就会自动拆箱调用**intValue**方法，得到对象里的值再进行比较。  
当一个整型传入Integer对象的equals方法里，也会发生自动装箱，java会自动将这个值打包装箱为Integer类。  

因此可以得出：  
 1). Integer类里的equals方法是重写过的，比较的是值  
 2). 发生自动装箱，那么要根据传入的值进行判断，如果不在[-128,127]这个范围，就会new一个Integer对象.  

[java基础中Integer值用==和equals判断相等问题解析](https://blog.csdn.net/w112736112736/article/details/77986283)
    
#   2. volatile和synorized关键字
在Java虚拟机规范中试图定义一种Java内存模型(**JMM**),来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。  
Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。  
如果一个程序想要并发的执行，那么必须保证原子性、可见性、一致性。   
  
  
**原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。  
可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。  
有序性：有序性：即程序执行的顺序按照代码的先后顺序执行**  

加入volatile关键字时，会多出一个lock前缀指令：
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  
   1)  它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成  
   2)  它会强制将对缓存的修改操作立即写入内存  
   3)  如果是写操作，它会导致其他CPU中对应的缓存行无效。    
   
synchronized则会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。
关于volatile和synchronized的区别：
1)  volatile本质是在告诉当前线程中的工作内存中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2)  volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3)  volatilebn能实现变量的修改可见性和有序性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性,有序性
4)  volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞

[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)
#   3. mysql 事务
事务是一个序列操作，其中的操作要么都执行，要么都不执行，它是一个不可分割的工作单位.事务有四大特性，被称作**ACID**。
### A(Atomicity) 原子性
事务就是一系列的操作，要么全部都执行，要都不执行。Mysql中通过使用 **回滚日志(undo log)** 来实现原子性。  

回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志逻辑地将数据库中的修改撤销掉看，可以理解为，我们在事务中使用的每一条 INSERT 都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。

## C(Consistency) 一致性
一致性是指事务将数据库从一种一致性状态变为下一种一致性状态。事务开始前和结束后，数据库的完整性约束没有被破坏。例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。

## I(Isolation) 隔离性
隔离性要求每个读写事务对其他事务的操作对象能相互分离。MySQL支持4种隔离级别：  
 1.  读未提交（READ UNCOMMITTED）
     任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交，会产生**脏读**。其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题。  
     事务A对某个数据进行修改，但是还未提交，如果事务B此时读取该数据就会读取到事务A中要修改的值，但是如果事务A要回滚，那么就会产生脏数据。  
     
 2.  读提交 （READ COMMITTED）
     读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。读提交就会产生**不可重复读问题**。不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的。流行的数据库都采用这种隔离级别，比如Oracle 和SQL Server,MySQL不是。  
     在同一事务中，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果。  
     
 3.  可重复读 （REPEATABLE READ）
     MySQL默认的隔离级别。而可重复读是指，事务不会读到其他事务对已有数据的修改，即使其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是会产生**幻读**问题。  
     
     **幻读**假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，
#   4. 关于mysql索引，是否命中索引
