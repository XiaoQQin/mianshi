<!-- TOC -->
[1. jvm内存的划分](#1-jvm内存的划分)  
[2. 类加载过程](#2-类加载过程)  
[3. 类加载器](#3-类加载器)  
[4. 双亲委派模型](#4-双亲委派模型)  
[5. 对象的创建](#5-对象的创建)  
[6. 垃圾收集算法](#6-垃圾收集算法)  
[7. 垃圾收集器](#7-垃圾收集器)
<!-- /TOC -->

## 1. jvm内存的划分

**线程私有**    

  
  1.  **虚拟机栈**:它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，虚拟机栈是为执行java方法服务。
  2.  **本地方法栈**: 和虚拟机栈相似，只不过它为执行本地方法服务
  3.  **程序计数器**：记录当前线程所执行的虚拟机字节码地址

**线程共享**

  1.  **堆**: 存放对象实例和数组定义，垃圾收集的主要区域，划分为新生代和老年代。
  2.  **方法区**: 用于存储已被虚拟机加载的类信息，常量，静态变量等


## 2. 类加载过程
类加载过程就是虚拟机将class 文件加载运行，类在运行期间第一次是使用动态加载，如果一次性加载，就会占用很多内存。类加载包括加载、验证、准备、解析和初始化这五个阶段。  

**加载**  
加载完成下面3个工作:  
  1.  通过类的完全限定名称获取定义该类的二进制字节流
  2.  将该字节流表示的静态存储结构转化为方法区的运行时存储结构
  3.  在内存中生成一个代表该类的class对象，作为方法区中该类各种数据的入口  
  
    
**验证**  
确保class文件的字节流中包含的信息符合当前虚拟机的要求  
  
**准备**  
为类变量分配内存并设置初始值，这个变量只是类的静态变量，而不是对象里的变量。**初始值**只是类型的默认值，比如int为0，boolean为false.定义为static int a=119,119是在初始化阶段才进行赋值的。  
  
**解析**  
虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。  
  
**初始化**    
真正开始执行类中定义的 Java 程序代码  
  
[javaGuide/类加载过程](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.md)

##  3. 类加载器  
java中所有的类都是由类加载器加载,加载的过程就是将.class文件加载到内存。  
JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自```java.lang.ClassLoader```。  
  
  1.  **启动类加载器(BootstrapClassLoader)**:最顶层的加载类，由C++实现，负责加载 **%JAVA_HOME%/lib**目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。  
  2.  **扩展类加载器(ExtensionClassLoader)**:主要负责加载目录 **%JRE_HOME%/lib/ext** 目录下的jar包和类,注意事项jre_home，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
  3.  **应用程序类加载器(AppClassLoader)**: 面向我们用户的加载器，加载当前应用**classpath**下的jar包和类。    
      

[javaGuide/类加载器](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.md#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%80%BB%E7%BB%93)
##   4. 双亲委派模型  
虚拟机中类加载器会默认使用**双亲委派模型**。即类加载的时候，会首先判断该类是否已经被加载过，已经加载过的类会直接返回，否则才会尝试加载。加载该类时，会首先将请求委派给该类的父类加载器进行加载(loadClass()方法),因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader中。当父类无法处理时，才有自己来进行处理。若父类加载器为null，则将启动类加载器(BootstrapClassLoader)作为父类加载器。  
  
**好处或者说是目的**   
双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载.也保证了 Java 的核心 API 不被篡改。因为jvm判断类是否相同不仅仅因为类名，相同的类使用不同的类加载器也会被当做不同的类。  
  
[javaGuide/双亲委派模型](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.md#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B)

##    5. 对象的创建  
对象的创建过程,虚拟机所做的工作以及流程。  

**step1 类加载检查**  
虚拟机遇到new时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个类是否已经被加载过，解析和初始化过。如果没有就执行类加载过程。  
**step2 分配内存**  
该过程就是虚拟机为java新生对象分配内存。对象所需内存的大小在类加载完成后便可确认,为对象分配内存即在java虚拟机的堆中将一块确认大小的内存块划分出来。  
分配方式有**指针碰撞**和**空闲列表** 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器所采用的垃圾收集算法决定的。**标记-整理**和**复制算法**对堆垃圾清理后不会产生内存碎片，**标记-清理**算法就会产生内存碎片。  
  
  **指针碰撞**:适合堆内存规整的情况，也就是没有内存碎片。用过的内存会划分到一边，中间有个分界指针。对象内存就分配在空闲内存那边，然后移动指针即可。  
  **空闲列表**：适合堆内存不规整，也就是有内存碎片的情况。虚拟机会维护一个列表，列表中记录那块内存时可用的。对象分配时找一块足够对象内存分配的内存，然后再更新列表即可。    

**step3 初试化零值**  
内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。    

**step4 设置对象头**  
初始化零值完成之后，虚拟机要对对象进行必要的设置。例如这个对象是哪个类的实例，对象的hash码等，这些数据都存放在**对象头**里。    

**step5 执行init方法**  
执行 new 指令之后会接着执行 <init> 方法，把对象按照代码初始化，这样一个真正可用的对象才算完全产生出来。

##   6. 垃圾收集算法  
**1.标记-清理算法**  
分为标记和清理两个阶段，先对存活的对象进行标记，完成后对未标记的对象进行回收。会产生内存碎片。  
  
**2.标记-整理算法**  
将存活对象移动到一端，并且对不存活的对象进行处理，不会产生内存碎片，但是因为要进行整理，所以速度会有所影响。  
  
**3.复制算法**  
将可用的内存划分为大小想的的两块，每次使用其中一块，当这块使用完，将存活的对象复制到另外一块，将使用过的空间进行清理。  
  
**4.分代回收算法**  
将java堆划分为新生代和老年代。  
新生代对象存活率低,每次收集都会有大量对象死去，使用**复制算法**。更加细致的是新生代分为eden,from survivor, to survivoto survivorr*,比例一般是8:1:1。为什么这样划分？是为了更好的回收内存。对象会优先在**eden区**分配内存，在一次新生代垃圾回收后，如果对象还存活，就会进入到**to survivor区**，并且对象的年龄还会加1，当它的对象年龄到达一个阀值(默认为15)就会进入老年代。存活对象进入**to survivor区**后，清理**eden**和**from**。这个时候**from**和**to**就会交换角色，也就是在每次垃圾回收时，确保**to survivor**是空的。这就是新生代的复制算法。  
  
 老年代对象存活率高，一般使用**标记-清理**或者**标记-整理**算法进行垃圾回收。
 ## 7. 垃圾收集器  
 **1.Serial 收集器**  
 串行收集器，最基本的收集器，使用单线程进行垃圾收集，在垃圾收集时必须暂停其他工作线程(stop the world)。新生代使用复制算法，老年代使用标记-整理算法。  
   
 **2.ParNew 收集器**  
 Serial 收集器的多线程版本  
   
 **3.CMS 收集器**  
 收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。实现了让垃圾收集线程与用户线程（基本上）同时工作。它使用**标记-清理**算法，所以无法浮动垃圾以及会产生内存碎片。  
 分为下面四个过程，其中并发标记所需要的时间最长:  
    1.  初始标记  
    2.  并发标记  
    3.  重新标记   
    4.  并发清理  
    
 **4.G1 收集器**  
 面向服务器的垃圾收集器，目前最先进的垃圾收集器。把堆划分为大小相等的区域，新生代和老年代不再物理隔离，使得每个小空间都可以单独的进行垃圾回收。
 整体来看使用**标记-整理**算法，但是从局部region之间，是使用**复制算法**的。  
 同样分为下面四个过程:  
    1.  初始标记  
    2.  并发标记  
    3.  最终标记   
    4.  筛选回收  
