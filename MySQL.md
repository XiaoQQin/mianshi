<!-- TOC -->
- [1. sql的join](#1-sql的join)  
- [2. 数据库存储引擎](#2-数据库存储引擎)  
  - [2.1 InnoDB和MyISAM](#21-InnoDB和MyISAM)  
- [3. 存储过程](#3-存储过程)  
- [4. MySQL的存储结构](#4-MySQL的存储结构)
  - [4.1 InnoDB行记录存储结构](#41-InnoDB行记录存储结构)  
  - [4.2 InnoDB数据页结构](#42-InnoDB数据页结构)
<!-- /TOC -->
## 1. sql的join  
下面都是最基本的join  

- 内连接(inner join)  
  内连接查询能将左表（表 A）和右表（表 B）中能关联起来的数据连接后返回。  
  ![内连接](https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/database/inner-join.png)  
  ```
  SELECT A.PK AS A_PK, B.PK AS B_PK,
     A.Value AS A_Value, B.Value AS B_Value
  FROM Table_A A
  INNER JOIN Table_B B
  ON A.PK = B.PK;
  ```
- 左连接(left join)  
  左连接查询会返回左表（表 A）中所有记录，不管右表（表 B）中有没有关联的数据。在右表中找到的关联数据列也会被一起返回。  
  ![左连接](https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/database/left-join.png)  
  ```
  SELECT A.PK AS A_PK, B.PK AS B_PK,
       A.Value AS A_Value, B.Value AS B_Value
  FROM Table_A A
  LEFT JOIN Table_B B
  ON A.PK = B.PK;
  ```
- 右连接(right join)  
  右连接查询会返回右表（表 B）中所有记录，不管左表（表 A）中有没有关联的数据。在左表中找到的关联数据列也会被一起返回。  
  ![右连接](https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/database/right-join.png)  
  ```
  SELECT A.PK AS A_PK, B.PK AS B_PK,
       A.Value AS A_Value, B.Value AS B_Value
  FROM Table_A A
  RIGHT JOIN Table_B B
  ON A.PK = B.PK;
  ```
- 全连接(full outer join)  
也被称作外连接，外连接查询能返回左右表里的所有记录，其中左右表里能关联起来的记录被连接后返回。  
![全连接](https://raw.githubusercontent.com/mzlogin/mzlogin.github.io/master/images/posts/database/full-outer-join.png)  
```
SELECT A.PK AS A_PK, B.PK AS B_PK,
       A.Value AS A_Value, B.Value AS B_Value
FROM Table_A A
FULL OUTER JOIN Table_B B
ON A.PK = B.PK;
```    
  
还有一些其他join，比如 **CROSS JOIN(笛卡尔集)**,**SELF JOIN**(返回表与自己连接后符合条件的记录，一般用在表里有一个字段是用主键作为外键的情况)等。  

## 2. 数据库存储引擎  
数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是存储引擎。我们主要关注两个MySQL存储引擎。  
  
### 2.1 InnoDB和MyISAM  
MySQL在5.5版本之前的数据库存储引擎默认为MyISAM,在5.5版本之后默认的存储引擎为InnoDB。最主要的是弄清楚这两个存储引擎之间的区别。  
  
两者的对比：  
  - **是否支持行锁**： MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。  
  - **是否支持事务**：MyISAM不支持事务，InnoDB支持事务
  - **是否支持外键**：MyISAM不支持外键，InnoDB支持
  - **是否支持MVCC**: 仅InnoDB支持MVCC,应对高并发事务, MVCC比单纯的加锁更高效。MVCC只有在事务的**读提交**和**可重复读**两个事务级别下工作。  
    
[JavaGuide/存储引擎](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/MySQL.md#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
## 3. 存储过程
一段SQL语句的预编译集合，可以理解为存储过程是存储在数据库中的一系列SQL操作的批处理。    

**优点**  
  
  - 重复使用
  - 安全性
  - 因为是预先编译的,因此具有很高的性能  
    
**缺点**  
  - 存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。  
  - 存储过程的性能调校与撰写，受限于各种数据库系统。  
## 4. MySQL的存储结构  
因为MySQL的默认数据库存储引擎为InnoDB,所以只分析InnoDB的存储结构
### 4.1 InnoDB行记录存储结构  
我们平时以记录(可以简单的理解为数据表中的一行数据)为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为**行格式或者记录格式**。InnoDB如今有4中不同的**行格式**,分别是**Compact**、**Redundant**、**Dynamic**和**Compressed**，这四种行格式原理大致相同，只分析**Compact**。  
  
可在建表时设置``ROW_FORMAT=行格式名称``来设置表的行格式，也可使用``ALTER TABLE 表名 ROW_FORMAT=行格式名称``来修改行格式。      
InnoDB记录的格式如下所示:  
  
![compact行格式示意图.PNG](https://i.loli.net/2020/04/30/HtdLDr27o8qAfw9.png)  
  
一条完整的记录可以分为**记录的额外信息**和**记录的真实数据**。  
  
#### 记录的额外信息  
记录的额外信息是服务器为了描述这条记录不得不添加的一些信息，额外信息分为3部分:**变长字段长度列表**、**NULL值列表**和**记录头信息**。  

1.  **记录头信息**: 把所有变长类型的列的长度都存放在记录的开头部位形成一个列表，按照列的顺序**逆序存放**。变长字段长度列表中只存储值为**非NULL**的列内容占用的长度，**值为NULL 的列**的长度是不储存的。    
  
    比如表中一行记录中C1,C2,C4的长度为4,3,1 。则根据逆序存放则为 01 03 04 (十六进制)  
    
2.  **NULL值列表**: Compact把值为NULL的列统一管理起来，存储到NULL值列表中。如果表中没有允许存储 NULL 的列，则 NULL值列表 也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列。  
      
     比如表中一行记录中c1,c3,c4为NULL，则NULL值列表为一个字节 0 0 0 0 0 1(c4) 1(c3) 0(c1),使用16进制为 06。      
     
  
![tc数据.png](https://i.loli.net/2020/04/30/Y89vgBykdxFcr41.png)  

   
   
3.  **记录头信息**:它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思，如下所示：  
  
  
![lutou.png](https://i.loli.net/2020/04/30/nR9Thg3viAmQwdp.png)
 
   
    
| 名称       | 大小(bit)         | 描述        |
|:-----------| :-------------:|:-------------:|
| 预留位1  | 1 | 没有使用 |
| 预留位2  | 1 | 没有使用 |
| deleta_mask  | 1 | 标记该记录是否被删除 |
| min_rec_mask | 1 | 标记该记录是否为B+树的非叶子节点中的最小记录 |
| n_owned  | 4 | 表示当前槽管理的记录数 |
| heap_no | 13 | 这个属性表示当前记录在本页中的位置  |
| record_type |3 | 表示当前记录的类型，0表示普通记录，1表示B+树非叶节点记录，2表示最小记录，3表示最大记录 |
| next_record | 16 | 它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量 |  
  
next_record非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。比方说第一条记录的next_record值为36，意味着从第一条记录的真实数据的地址处向后找36个字节便是下一条记录的真实数据。如果你熟悉数据结构的话，就立即明白了，这其实是个链表，可以通过一条记录找到它的下一条记录。但是需要注意注意再注意的一点是，**下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录**。而且规定 最小记录 的下一条记录就本页中主键值**最小的记录**，而本页中主键值最大的记录的下一条记录就是**最大记录** 。也就是页结构中中保存的**Infimum + Supremum**。  

```
这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗,
所以只是打个删除标记而已，而且这部分存储空间之后还可以重用，
也就是说之后如果有新记录插入到表中的话,可能把这些被删除的记录占用的存储空间覆盖掉。  
  
如果你想彻底的从磁盘上移除这些被删除的记录，可以使用这个语句：

`optimize table 表名;`

执行这个命令后服务器会重新规划表中记录的存储方式，把被标记为删除的记录从磁盘上移除。
```
#### 记录真实数据  
  
记录的真实数据除了我们插入的那些列的数据，MySQL会为每个记录默认的添加一些列，MySQL服务器会为每条记录都添加 transaction_id 和 roll_pointer 这两个列，但是 row_id 只有在表没有定义主键的时候才会为记录添加，相当于MySQL服务器帮我们来添加一个主键。    

 | 名称       | 是否必须        | 占用空间      |     描述      |
|:-----------| :-------------:|:-------------:|:-------------:|
| row_id	  | 否     |	6字节	| 行ID，唯一标识一条记录 |
| transaction_id | 是	| 6字节	| 事务ID |
| roll_pointer | 是	| 7字节	| 回滚指针 |  
  
### 4.2 InnoDB数据页结构  
  
页的本质就是一块16KB大小的存储空间，InnoDB为了不同的目的而把页分为不同的类型，其中用于存放记录的页也称为**数据页**。一个InnoDB数据页的存储空间被划分成了**7**个部分。  
  
![sj页结构.PNG](https://i.loli.net/2020/05/01/I4ESnXcFVpwqfNi.png)
 
  
| 名称       | 大小(字节)         | 描述        |
|:-----------| :-------------:|:-------------:|
| File Header | 固定的38字节 | 描述的就是页外的各种状态信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁 |
| Page Header | 固定的56个字节 | 专门存储页里的各种状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等 |
| Infimum + Supremum | 固定的26个字节 | 两个虚拟的伪记录，分别表示页中的最小和最大记录 |
| User Records | 大小不固定 | 真实存储我们插入的记录的部分 |
| Free Space | 大小不固定 | 页中尚未使用的部分 |
| Page Directory | 大小不固定 | 页中的记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。 |
| File Trailer | 固定的8个字节 | 用于检验页是否完整的部分 |  
  
在页的7个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到User Records部分。但是在一开始生成页的时候，其实并没有User Records这个部分，每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分，当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话,就要去申请新的数据页。    
  
不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照**主键值由小到大的顺序**连接起来的。    
  
```
最小记录(伪记录,Infimum) -> 真实记录1 -> 真实记录2 -> ... -> 真实记录n -> 最大记录(伪记录,Supremum)
```  
#### 页目录  
记录按照主键值从小到大在数据页中形成一个单链表，当页面中记录过多时，为了查找更方便，不再从头到尾遍历，设计了页目录：    
   -  将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组  
   -  每个组的最后一条记录的头信息中的**n_owned**属性表示该组内共有几条记录  
   -  将每个组的最后一条记录的地址偏移量按顺序存储起来，每个地址偏移量也被称为一个**槽（英文名：Slot）**。这些地址偏移量都会被存储到靠近页的尾部的地方，页中存储地址偏移量的部分也被称为**Page Directory**。  
   -  对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在1-8条之间，剩下的分组中记录的条数范围只能在是4-8条之间。  

**如何将记录进行分组？**  
  
  
1)  初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。  
2)  之后每插入一跳记录都把这条记录放到最大记录所在的组，直到最大记录所在组中的记录数等于8个  
3)  在最大记录所在组中的记录数等于8个的时候再插入一条记录时，将最大记录所在组平均分裂成2个组，然后最大记录所在的组就剩下4条记录了，然后就可以把即将插入的那条记录放到该组中了。  
  
**页面中根据主键查找记录**  
  
1)  通过二分法确定该记录所在的槽。
2)  通过记录的next_record属性组成的链表遍历查找该槽中的各个记录。  
  
#### 数据页之间的结构  
每页都有  **File Header** 部分，它里面包含着本页的上一个和下一个数据页的页号，所以所有的数据页会组成一个**双链表**。  

## 5. 数据库索引  
索引是一种用于快速查询和检索数据的数据结构，比较常见的的索引结构为:B树，B+树和Hash。数据库可以通过索引加快数据的检索，索引就好比书中的目录一样，可以快速定位数据所在的位置。  

### 5.1 索引的优缺点分析  
**索引的优点**  
  - 可以大大加快数据的检索速度，这是最大的优点  
  - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。  
  - 随机IO变为顺序IO   
**索引的缺点**  
  
  - 创建索引和维护索引需要耗费时间:当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL执行效率  
  - 占用物理存储空间: 索引需要使用物理文件存储，也会耗费一定空间。  
  
### 5.2 B树和B+树的区别  
  
 - 1. B树的所有节点即存放key也存放data；而B+树只有叶子节点存放Key和data,其他非叶子节点都只存放Key  
 - 2. B树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与它相邻的叶子节点。  
 - 3. B+树的检索效率更加稳定，任何查找都是从根节点到叶子节点的过程。    
   
#### 关于Hash索引    
   
   
 **Hash索引不支持顺序查找和范围查找是它最大的缺点**。类似下列语句  
   
 ```
 SELECT * FROM tb1 WHERE id < 500;
 ```
 使用B+树索引的话,因为是有序的吗,在这种范围查询中，优势非常大，直接遍历比500小的叶子节点。而hash索引是根据hash算法来定位的，难不成还要把 1 - 499的数据，每个都进行一次hash计算来定位吗。  
 
### 5.3 索引为什么可以加快数据库的检索速度  

#### InnoDB的存储结构  
  
MySQL的基本存储结构是**页**,也就是记录都存在**页**里。  
  -  数据页之间组成一个**双向链表**  
  -  数据页里面的记录又会组成一个**单向链表**,每个数据页都会为存储在页里的记录生成一个**页目录** 
       -  通过**主键**在数据页里查询记录时可以在**页目录**里进行**二分查找**快速定位到对应的槽，            然后再遍历该槽对应分组中的记录即可快速找到指定的记录  
       -  以**非主键**为搜索条件，只能从最小记录开始依次遍历单链表中的每条记录。  
       
如果以如下```select * from user where username = 'Java3y'```没有使用任何优化的SQL语句查询,那么数据库会如下进行检索数据，在数据量很大的情况下会很慢：  
  
  - 定位到记录所在的页，需要遍历双向链表，找到所在的页。  
  - 从定位所在的页内查找相应的记录，不是根据主键查询，只能遍历所在页的单链表。 
#### InnoDB索引结构  
索引其实就是一个数据结构，这个结构里根据key(建立索引指定的列)已经将记录排好了序，可以很快的检索到记录对应的数据页(也就是上述中将**定位到记录所在的页**变得很快)。  
InnoDB中的索引是一棵B+树，一般说非叶子节点不存储数据(数据库中的记录),叶子节点存储数据。其实非叶子节点存储的我们可以称为**目录项记录**,所以说索引就像目录一样。    
上述[记录的数据格式](https://github.com/XiaoQQin/mianshi/edit/master/MySQL.md#InnoDB数据页结构)中有一个字段为 **record_type**:   
  
| 值       | 描述         |
|:-----------| :-------------:|
| 0 | 普通的用户记录 |
| 1 | 目录项记录 |
| 2 | 最小记录 |
| 3 | 最大记录 |  
  
目录项记录中 **record_type** 为  1，B+树叶子节点中 **record_type** 为 0 ,然后每个数据页中都有 **record_type** 为 2 和 3 的两条伪记录。B+树的索引如下所示  
![索引结构.PNG](https://i.loli.net/2020/05/01/DZpx2u1qX5fnyjk.png)    
上图可以看出B+树索引树叶子结构为:  
![索引叶子结构.PNG](https://i.loli.net/2020/05/01/vNYrbwCE1iDJyoj.png)  
那么我们查找一条记录流程如下：
- 确定**目录项记录**页：根据每页的目录项的主键值范围查到对应的**目录项页**，或许可以理解为查找B+树某个叶子节点的父节点    
- 通过**目录项记录** 页确定用户记录真实所在页，可以理解为查找到叶子节点  
- 在真实存储用户记录的页中定位到具体的记录。  
  
这样就可以回答为什么索引可以加快检索记录：  
InnoDB的存储结构为数据页，每页为16k,页与页之间会建立双向链表，我们遍历一条记录需要根据双向链，找到对应记录所在的数据页。在这过程中需要遍历每个经过数据页中的的记录，如果建立索引，由于建立的索引是根据列进行排序的，可以很快的定位到用户记录所在的数据页。  

### 5.4 索引的分类  

#### 聚簇索引  
聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。它有下面两个特点
1) 使用记录主键值的大小进行记录和页的排序，即**页与页之间和页内都是有序的**。这包括:  
   - 页内的记录是按照主键的大小顺序排成一个单向链表(页内)  
   - 存放用户记录的数据页是根据主键的大小排成一个双向链表(页与页之间)
   - 存放目录项记录的页根据主键的大小排成一个双向链表(页与页之间)
2) B+树的叶子节点存储的是完整的用户记录，所谓完整的用户记录，就是指这个记录中存储了所有列的值。  
  
这种聚簇索引并不需要我们在MySQL语句中显式的去创建，InnoDB存储引擎会**自动的为我们创建聚簇索引**(没有设置主键的话会自动添加一个主键)。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据。  

#### 二级索引  
不是依照主键建立的索引，思想和聚簇索引一样，将主键改变为建立索引的列，但是最主要的一点是**二级索引的叶子节点不是聚簇索引一样存储的是完整的记录数据，它存放的是主键，我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录**。  
  
这样做的原因是为了节省空间和性能，如果将完整的用户记录放到叶子节点是可以不用回表(也就是根据主键再查询一次)，但是极大的浪费空间，相当于每建立一棵B+树都需要把所有的用户记录再都拷贝一遍。
  
#### 联合索引  
以多个列的大小作为排序规则，建立索引。
## 6. 事务
