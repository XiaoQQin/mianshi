<!-- TOC -->
[1. jvm内存的划分](#1-jvm内存的划分)  
[2. 类加载过程](#2-类加载过程)  
[3. 类加载器](#3-类加载器)  
[4. 双亲委派模型](#4-双亲委派模型)  
[5. 对象的创建](#5-对象的创建)  
[6. 垃圾收集算法](#6-垃圾收集算法)  
[7. 垃圾收集器](#7-垃圾收集器)  
[8. 判断一个对象是否可以被回收](#8-如何判断对象是否可以被回收)  
[9. minor GC和full GC](#9-minor GC和full GC)    
[10. 内存分配策略-对象什么时候进入老年代?](#10-内存分配策略-对象什么时候进入老年代?)  
[11. jvm中的参数](#11-jvm中的参数)  
[12. java中堆和栈的区别](#12-java中堆和栈的区别)  
[13. 内存泄漏和内存溢出](#13-内存泄漏和内存溢出)
<!-- /TOC -->

## 1. jvm内存的划分

**线程私有**    

  
  1.  **虚拟机栈**:它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，虚拟机栈是为执行java方法服务。
      每个线程都有自己的空间，这个线程内所有方法都在改线程内执行**FILO**操作。每个方法都分配一块空间，叫做**栈帧**。栈帧内的结构为：
      - 局部变量表：存储该方法内的局部变量的地址  
      - 操作数栈： 存放方法中的计算结果的临时存放区域。
      - 动态链接： 该方法内引用其他方法的方法区内的地址
      - 方法出口： 该方法的出口，表明方法结束后执行流程
  2.  **本地方法栈**: 和虚拟机栈相似，只不过它为执行本地方法服务,本地方法使用**native**进行修饰
  3.  **程序计数器**：记录当前线程所执行的虚拟机字节码地址

**线程共享**

  1.  **堆**: 存放对象实例和数组定义，垃圾收集的主要区域，划分为新生代和老年代。
  2.  **方法区**: 用于存储已被虚拟机加载的类信息，常量，静态变量等


## 2. 类加载过程
类加载过程就是虚拟机将class 文件加载运行，类在运行期间第一次是使用动态加载，如果一次性加载，就会占用很多内存。类加载包括加载、验证、准备、解析和初始化这五个阶段。  

**加载**  
加载完成下面3个工作:  
  1.  通过类的完全限定名称获取定义该类的二进制字节流
  2.  将该字节流表示的静态存储结构转化为方法区的运行时存储结构
  3.  在内存中生成一个代表该类的class对象，作为方法区中该类各种数据的入口  
  
    
**验证**  
确保class文件的字节流中包含的信息符合当前虚拟机的要求  
  
**准备**  
为类变量分配内存并设置初始值，这个变量只是类的静态变量，而不是对象里的变量。**初始值**只是类型的默认值，比如int为0，boolean为false.定义为static int a=119,119是在初始化阶段才进行赋值的。  
  
**解析**  
虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。  
  
**初始化**    
真正开始执行类中定义的 Java 程序代码  
  
[javaGuide/类加载过程](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.md)

##  3. 类加载器  
java中所有的类都是由类加载器加载,加载的过程就是将.class文件加载到内存。  
JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自```java.lang.ClassLoader```。  
  
  1.  **启动类加载器(BootstrapClassLoader)**:最顶层的加载类，由C++实现，负责加载 **%JAVA_HOME%/lib**目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。  
  2.  **扩展类加载器(ExtensionClassLoader)**:主要负责加载目录 **%JRE_HOME%/lib/ext** 目录下的jar包和类,注意事项jre_home，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
  3.  **应用程序类加载器(AppClassLoader)**: 面向我们用户的加载器，加载当前应用**classpath**下的jar包和类。    
      

[javaGuide/类加载器](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.md#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%80%BB%E7%BB%93)
##   4. 双亲委派模型  
虚拟机中类加载器会默认使用**双亲委派模型**。即类加载的时候，会首先判断该类是否已经被加载过，已经加载过的类会直接返回，否则才会尝试加载。加载该类时，会首先将请求委派给该类的父类加载器进行加载(loadClass()方法),因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader中。当父类无法处理时，才有自己来进行处理。若父类加载器为null，则将启动类加载器(BootstrapClassLoader)作为父类加载器。  
  
**好处或者说是目的**   
双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载.也保证了 Java 的核心 API 不被篡改。因为jvm判断类是否相同不仅仅因为类名，相同的类使用不同的类加载器也会被当做不同的类。  
  
[javaGuide/双亲委派模型](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.md#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B)

##    5. 对象的创建  
对象的创建过程,虚拟机所做的工作以及流程。  

**step1 类加载检查**  
虚拟机遇到new时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个类是否已经被加载过，解析和初始化过。如果没有就执行类加载过程。  
**step2 分配内存**  
该过程就是虚拟机为java新生对象分配内存。对象所需内存的大小在类加载完成后便可确认,为对象分配内存即在java虚拟机的堆中将一块确认大小的内存块划分出来。  
分配方式有**指针碰撞**和**空闲列表** 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器所采用的垃圾收集算法决定的。**标记-整理**和**复制算法**对堆垃圾清理后不会产生内存碎片，**标记-清理**算法就会产生内存碎片。  
  
  **指针碰撞**:适合堆内存规整的情况，也就是没有内存碎片。用过的内存会划分到一边，中间有个分界指针。对象内存就分配在空闲内存那边，然后移动指针即可。  
  **空闲列表**：适合堆内存不规整，也就是有内存碎片的情况。虚拟机会维护一个列表，列表中记录那块内存时可用的。对象分配时找一块足够对象内存分配的内存，然后再更新列表即可。    

**step3 初试化零值**  
内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。    

**step4 设置对象头**  
初始化零值完成之后，虚拟机要对对象进行必要的设置。例如这个对象是哪个类的实例，对象的hash码等，这些数据都存放在**对象头**里。    

**step5 执行init方法**  
执行 new 指令之后会接着执行 <init> 方法，把对象按照代码初始化，这样一个真正可用的对象才算完全产生出来。

##   6. 垃圾收集算法  
**1.标记-清理算法**  
分为标记和清理两个阶段，先对存活的对象进行标记，完成后对未标记的对象进行回收。会产生内存碎片。  
  
**2.标记-整理算法**  
将存活对象移动到一端，并且对不存活的对象进行处理，不会产生内存碎片，但是因为要进行整理，所以速度会有所影响。  
  
**3.复制算法**  
将可用的内存划分为大小想的的两块，每次使用其中一块，当这块使用完，将存活的对象复制到另外一块，将使用过的空间进行清理。  
  
**4.分代回收算法**  
将java堆划分为新生代和老年代。  
新生代对象存活率低,每次收集都会有大量对象死去，使用**复制算法**。更加细致的是新生代分为eden,from survivor, to survivoto survivorr*,比例一般是8:1:1。为什么这样划分？是为了更好的回收内存。对象会优先在**eden区**分配内存，在一次新生代垃圾回收后，如果对象还存活，就会进入到**to survivor区**，并且对象的年龄还会加1，当它的对象年龄到达一个阀值(默认为15)就会进入老年代。存活对象进入**to survivor区**后，清理**eden**和**from**。这个时候**from**和**to**就会交换角色，也就是在每次垃圾回收时，确保**to survivor**是空的。这就是新生代的复制算法。  
  
 老年代对象存活率高，一般使用**标记-清理**或者**标记-整理**算法进行垃圾回收。
 ## 7. 垃圾收集器  
 **1.Serial 收集器**  
 串行收集器，最基本的收集器，使用单线程进行垃圾收集，在垃圾收集时必须暂停其他工作线程(stop the world)。新生代使用复制算法，老年代使用标记-整理算法。  
   
 **2.ParNew 收集器**  
 Serial 收集器的多线程版本  
   
 **3.CMS 收集器**  
 收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。实现了让垃圾收集线程与用户线程（基本上）同时工作。它使用**标记-清理**算法，所以无法浮动垃圾以及会产生内存碎片。  
 分为下面四个过程，其中并发标记所需要的时间最长:  
    1.  初始标记  
    2.  并发标记  
    3.  重新标记   
    4.  并发清理  
    
 **4.G1 收集器**  
 面向服务器的垃圾收集器，目前最先进的垃圾收集器。把堆划分为大小相等的区域，新生代和老年代不再物理隔离，使得每个小空间都可以单独的进行垃圾回收。
 整体来看使用**标记-整理**算法，但是从局部region之间，是使用**复制算法**的。  
 同样分为下面四个过程:  
    1.  初始标记  
    2.  并发标记  
    3.  最终标记   
    4.  筛选回收  
##  8. 如何判断对象是否可以被回收
堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。  
**1.引用计数法**  
  
给对象添加一个引用计数器，每当该对象被引用，加1；每当引用失效，减1。当对象引用计数为0时，表明该对象可以被回收。由于无法解决对象之间循环引用相互循环引用的问题，所有虚拟机一般不使用该方法。  
  
**2.可达性分析**  
  
通过一系列的称为**GC Roots**的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到**GC Roots**没有任何引用链相连的话，则证明此对象是不可用的。一般**GC roots**包括：  
  1.  方法区中类静态属性引用的对象
  2.  方法区中的常量引用的对象  
  3.  虚拟机栈中局部变量表中引用的对象
  4.  本地方法栈中 JNI 中引用的对象

##  9. minor GC和full GC 
**minor GC**:对新生代进行回收，新生代对象存活时间很短，因此minor GC会频繁发生，执行速度也很快  
**full GC**: 回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多  
  
**什么时候进行full GC?**  
  1. 调用System.gc():只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行  
  2. 老年代空间不足:这是最主要的原因，老年代空间不足的常见原因是创建过大的数组，或者是过大的对象，长期存活的对象进入老年代导致空间不足。  

##  10. 内存分配策略-对象什么时候进入老年代?
  1.  对象优先会分配在**Eden区**,若经过多次GC后会进入到**survivor区**和**老年代**(默认对象年龄为15)。
  2.  大对象直接进入老年代，即需要大量连续内存空间的java对象，比如很大的数组。
  3.  长期存活的对象进入老年代，虚拟机给每个对象定义年龄计数器，在survivor每经历过一次minor GC，年龄就加1，当超过15时，就会进入老年代。
##  11. jvm中的参数
  **-xms**: jvm启动时申请的初始堆大小  
  **-xmx**: jvm启动的最大堆的大小
##  12. java中堆和栈的区别  
栈是线程私有的，用来为执行java方法服务，堆是共享的，用来分配对象实例。  
java中的栈中存储的是一个个栈帧，每个java方法执行都会创建一个栈帧，用于存储局部变量，操作数常量，常量应用等。方法调用执行就是一个个栈帧在栈中入栈和出栈的过程。
##  13. 内存泄漏和内存溢出  
  
**内存溢出**:即系统不能再分配出所需要的空间。内存溢出时，检查虚拟机的参数，看是否可以将参数调大一些，或者从代码上查看哪些对象生命周期过长，优化代码结构。  
  
**内存泄漏**：所分配过内存空间不能进行回收，造成可用的内存越来越少。  

**解决java堆溢出问题**  
首先使用内存映像分析工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清除到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。    
  
  
 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确的定位出泄漏代码的位置。    
   
   
 如果不存在泄漏，换句话说，就是内存中的对象确实还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少的程序运行期的内存消耗。
