<!-- TOC -->
- [1. OSI与TCP/IP网络模型](#1-OSI与TCP/IP网络模型)  
  - [1.1 OSI七层模型](#11-OSI七层模型)  
  - [1.2 TCP/IP五层模型](#12-TCP/IP五层模型)  
- [2. TCP三次握手与四次挥手](#2-TCP三次握手与四次挥手)  
  - [2.1 TCP三次握手](#21-TCP三次握手)  
  - [2.2 四次挥手](#22-四次挥手)  
- [3. TCP和UDP协议的区别](#3-TCP和UDP协议的区别)  
- [4. 从输入URL到页面加载发生了什么](#4-从输入URL到页面加载发生了什么)    
- [5. 网络层协议](#5-网络层协议)  
- [6. 应用层协议](#6-应用层协议)  
- [7. Cookie和Session](#5-Cookie和Session)  
- [8. 关于HTTP](#8-关于HTTP)  
  - [8.1 HTTP和HTTPS的区别](#81-HTTP和HTTPS的区别)  
  - [8.2 get和post的区别](#82-get和post的区别)  
  - [8.3 HTTP长连接和短连接](#83-HTTP长连接和短连接)  
  - [8.4 http请求报文和响应报文的区别](#84-http请求报文和响应报文的区别)  
  - [8.5 状态码](#85-状态码)  
- [9. 关于RESTful](#9-关于RESTful)  
- [10. URI和URL的区别](#10-URI和URL的区别)  
- [11. TCP流量控制和拥塞控制](#11-TCP流量控制和拥塞控制)  
  - [11.1 流量控制](#111-流量控制)  
  - [11.2 拥塞控制](#112-拥塞控制)  
  - [11.3 流量控制和拥塞控制的区别](#113-流量控制和拥塞控制的区别)
<!-- /TOC -->
## 1. OSI与TCP/IP网络模型
### 1.1 OSI七层模型
![osi七层模型](https://user-gold-cdn.xitu.io/2019/8/31/16ce7c55e2003c1b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
### 1.2 TCP/IP五层模型  
其实TCP/IP只有4层，包括：**应用层、传输层、网络互连层、网络链接层**，但是综合OSI七层模型，我们一般称作5层，所以平时称TCP/IP五层模型也没错。  
![tcp/ip五层模型](https://user-gold-cdn.xitu.io/2019/8/31/16ce7e7fe7d7c181?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
  
- **应用层**:为应用程序提供网络服务。在互联网中应用层协议很多，如域名系统**DNS**，支持万维网应用的**HTTP协议**，支持电子邮件的**SMTP协议**等等。我们把应用层交互的数据单元称为**报文**。 
  

- **传输层**:负责向两台主机进程之间的通信提供通用的数据传输服务,也就是我们所说的端对端传输。  
   运输层主要使用以下两种协议：  
      - **TCP**：提供面向连接的，可靠的数据传输服务。  
      - **UDP**：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
  
- **网络层**：网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。也就是ip寻址、路由选择和数据传输。网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。  
  
- **数据链路层**： 控制网络层和物理层之间的通信，提供介质访问和链路管理。物理寻址，将原始比特流传输转变为逻辑传输路线。  
  
- **物理层**: 原始比特流的传输
  
### 网络模型的设备和协议  
在网络模型的每一层都工作着不同的设备，，如下图所示：  
![设备工作](https://user-gold-cdn.xitu.io/2019/8/31/16ce7eb72c0dc44c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
  
每一层的主要协议如下所示：  
  
![协议](https://user-gold-cdn.xitu.io/2019/8/31/16ce7ee86d166933?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
  
通常需要注意以下协议；  
- **HTTP、HTTPS在应用层**
- **TCP、UDP在传输层**  
- **IP在网络层**
  
    
[JavaGuide/计算机网络](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)        
[网络模型--OSI & TCP/IP](https://juejin.im/post/5d398dc26fb9a07ecb0bedde)
  
## TCP保证可靠传输的保证、拥塞控制目的和过程
**TCP通过**：应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、ARP协议、超时重传等方式保证数据的可靠性
**拥塞控制的目的**：防止过多的数据注入到网络中，造成网络拥塞  
**拥塞控制的过程**：发送方维持一个拥塞窗口的状态变量，该变量随着网络的拥塞情况进行变化，使用慢开始，拥塞避免、快重传和快恢复等方法进行拥塞控制。
## TCP粘包
**TCP粘包**：发送方发送的若干数据包到接收方接受时粘成一包  
**发送方原因**:TCP默认使用Nagle算法（主要作用：为了尽可能发送大块数据，避免网络中充斥着许多小数据块。)Nagle算法造成了发送方可能会出现粘包问题
**接收方原因**:TCP接收到数据包时，并不会马上交给应用层进行处理。实际上TCP将接受到的数据包保存在接受缓存里，然后应用程序主动从缓存读取收到的分组。如果TCP接受数据包缓存的速度大于应用程序缓存总读取数据包的速度，多个包就会缓存，就会造成数据粘包
## 2. TCP三次握手与四次挥手
### 2.1 TCP三次握手  
    
![三次握手.PNG](https://i.loli.net/2020/05/04/1kURADPvgrYObF2.png)
![TCP三次握手](https://camo.githubusercontent.com/f6dfce1f05e95f94dbcc4b0bee8c4e3acbfb9f30/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67)  
  
**简单描述**:  
  
  - 客户端发送带有**SYN**标志的数据包，一次握手  
  - 服务器发送带有**SYN/ACK**标志的数据包，二次握手  
  - 客户端发送带有**ACK**标志的数据包，三次握手  
  
#### 为什么要三次握手？  
  
三次握手的目的是建立可靠的通信信道,三次握手就是双方确认自己与对方的发送与接收是正常的。  
  
- 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
- 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接受正常；Server确认了：对方发送正常，自己接受正常  
- 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接受正常：Server确认了：对方发送正常、接收正常，自己发送、接受正常。  
  
 所以三次握手就能确认客户端和服务器收发功能都正常，缺一不可。  
   
#### 第2次握手传回了ACK，为什么还要传回SYN？  
服务器回传给客户端SYN是为了**建立并确认从服务端到客户端的通信**。  

#### 两次握手会怎么样？  
有这样一种情况，当A发送一个消息给B，但是由于网络原因，消息被阻塞在了某个节点，然后阻塞的时间超出设定的时间，A会认为这个消息丢失了，然后重新发送消息。 
    

当A和B通信完成后，这个被A认为失效的消息，到达了B。对于B而言，以为这是一个新的请求链接消息，就向A发送确认;对于A而言，它认为没有给B再次发送消息（因为上次的通话已经结束）所有A不会理睬B的这个确认，但是B则会一直等待A的消息。  
这就导致了B的时间被浪费（对于服务器而言，CPU等资源是一种浪费），这样是不可行的，这就是为什么不能两次握手的原因了。

二次握手会出现**已失效的请求报文段突然又传送到了服务端而产生连接的误判**的情况。三次握手就是防止已失效的请求报文段突然又传送到了服务端而产生连接的误判，也就是防止服务器资源因为错误数据而一直等待，浪费资源。
[TCP为什么是三次握手和四次挥手](https://blog.csdn.net/yu876876/article/details/81560122)
### 2.2 四次挥手  
![四次挥手.png](https://i.loli.net/2020/05/04/yAmKi32XvsnSJHz.png)    
![四次挥手](https://camo.githubusercontent.com/66e3447783e22d736f7db9c7d121e8eba54f07c0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f5443502545352539422539422545362541432541312545362538432541352545362538392538422e706e67)
  
**简要描述**：  
  - 客户端发送一个**FIN**，用来关闭客户端到服务器的数据传输，客户端进入**FIN-WAIT-1状态**  
  - 服务器接收到这个**FIN**,他发回一个**ACK**，确认的序号为收到的序号加1，服务器就进入**CLOSE-WAIT**状态。  
  - 服务器关闭与客户端的链接，发送一个**FIN**给客户端，客户端进入**FIN-WAIT-2**状态    
  - 客户端发回**ACK**报文确认，确认序号设置为收到序号加1，**TIME-WAIT**状态。  
**CLOSE-WAIT**: 这种状态的含义其实是表示在等待关闭  
**TIME-WAIT**：确保连接方能在时间范围内，关闭自己的连接  
  
#### 为什么需要TIME-WAIT状态要保持2MSL  
2MSL=去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。
- 客户端(A)要确认服务器端(B)收到了自己发送的ACK，如果服务器没有接收到ACK,则会重新发送FIN,当retry times到了上限，就会reset连接
- 如果不等，释放的端口可能会重连刚断开的服务器端口，这样依旧存活的在网络中的老TCP报文可能与新TCP连接报文冲突，造成数据冲突。为避免这种情况，需要耐心等待网络老的tcp连接的活跃报文全都失效。

## TCP报文格式  
![176673786_1597021487780_27194088468_4cb0141fc8_b.jpg](https://i.loli.net/2020/08/11/I3A7Zp9DEFa8OSo.jpg)  
- **源端口和目的端口**：用于寻找发送端和目的端的应用程序。这两个值加上ip首部源端ip地址和目的端ip地址唯一确认一个tcp连接  
- **序号**：序号是本报文段发送的数据组的第一个字节的序号
- **确认号**：确认序号应当是上次已成功收到数据字节序号加 1，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。  
- **数据偏移**：数据部分距离报文段起始处的偏移量，实际上指的是首部的长度  
- **控制位**：  
  - URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。  
  - ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。
  - PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队 
  - RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。
  - SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1 
  - FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。
- **窗口**：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制
- **校验和** ：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得
- **紧急指针**：只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。
## UDP报文格式
首部字段只有 8 个字节，包括**源端口、目的端口、长度、检验和**，每个为2个字节。12 字节的伪首部是为了计算检验和临时添加的。
 #### 为什么要四次挥手？  
TCP是全双工模式，客户端和服务器都可以发送和接受数据。这就意味着，当客户端发出FIN报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；但是，这个时候客户端还是可以接受来自服务器的数据；当服务器返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是服务器还是可以发送数据到客户端的；当服务器也发送了FIN报文段时，这个时候就表示服务器也没有数据要发送了。  
  
  
## 3. TCP和UDP协议的区别  
![tcp和udp的区别](https://camo.githubusercontent.com/582cf0bd58f1b7859ff7696d0345200d133bee88/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f7463702d76732d7564702e6a7067)
- TCP是面向连接，可靠传输的;UDP是面向无连接，传输不可靠的。  
- TCP传输效率更慢，UDP传输更快  
- TCP一般应用在要求数据传输可靠的场景，比如邮件传输，远程登录；UDP一般应用在要求传输速度快的场景，比如视频会议，语音通话。  
  
## 4. 从输入URL到页面加载发生了什么  
- **DNS解析**:DNS解析的过程就是寻找哪台机器上有你需要资源的过程，实现了网址到IP地址的转换,DNS解析是一个递归查询的过程。  
- **TCP连接**: 三次握手  
- **发送HTTP请求**  
- **服务器处理请求并返回HTTP报文**  
- **浏览器解析渲染页面**
- **连接结束**  
  
具体请看：[前端经典面试题: 从输入URL到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)  
## 5. 网络层协议
网络层的协议基于ip数据报
-  **地址解析协议ARP:** ARP实现由IP地址得到MAC地址
-  **网际控制报文协议ICMP:** ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。**Ping是ICMP的一个重要应用，主要用来测试两台主机之间的连通性**。
## 6. 应用层协议
### 6.1. DNS协议
DNS同时占用UDP和TCP端口35，DNS会同时使用TCP和UDP协议。DNS在两种情况下会使用TCP协议：
- **DNS在进行区域传输的时候使用TCP协议**  
  DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer） 
- **如果返回的响应超过512个字节**  
  UDP 最大只支持 512 字节的数据
#### 为什么既使用TCP又使用UDP
通俗地讲，就是DNS服务器之间传输时使用TCP，而客户端与DNS服务器之间传输时用的是UDP  
- 区域传输时使用TCP
   -  辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多  
   -  TCP是一种可靠的连接，保证了数据的准确性
-  域名解析时使用UDP协议  
   -  客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快
### 6.2 FTP协议
ftp使用TCP进行连接，当进行文件传输时，需要建立两个连接，FTP同时使用**20、21**两个端口。  
- **控制连接:** 服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。  
- **数据连接:** 用来传输一个文件数据  
  
  
根据数据连接是否由服务器端主动建立，FTP有**主动和被动两种模式**   
- **主动模式:** 服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。  
- **被动模式:** 客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 
### 6.3 远程登录协议  
**TELNET协议** 用于登录到远程主机上，并且远程主机上的输出也会返回，基于TCP协议，使用23端口。  
### 6.4 电子邮件协议  
邮件协议包含发送协议和读取协议，发送协议常用**SMTP**，读取协议常用**POP3和IMAP**。
- **SMTP**  
SMTP协议作用于：用户客户端-> 发送方服务器、发送方服务器-> 接收方服务器  
- **POP3**  
POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件  
- **IMAP**  
IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除
#### 常用端口  
|应用| 应用层协议 | 端口号 | 传输层协议 | 备注 |
| :---: | :--: | :--: | :--: | :--: |
| 域名解析 | DNS | 53 | UDP/TCP | 长度超过 512 字节时使用 TCP |
| 动态主机配置协议 | DHCP | 67/68 | UDP | |
| 简单网络管理协议 | SNMP | 161/162 | UDP | |
| 文件传送协议 | FTP | 20/21 | TCP | 控制连接 21，数据连接 20 |
| 远程终端协议 | TELNET | 23 | TCP | |
| 超文本传送协议 | HTTP | 80 | TCP | |
| 简单邮件传送协议 | SMTP | 25 | TCP | |
| 邮件读取协议 | POP3 | 110 | TCP | |
| 网际报文存取协议 | IMAP | 143 | TCP | |

参考来源：[cyc2018/cs-Notes/计算机网络](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E5%BA%94%E7%94%A8%E5%B1%82.md#%E6%96%87%E4%BB%B6%E4%BC%A0%E9%80%81%E5%8D%8F%E8%AE%AE)


## 7. Cookie和Session  
  
-  Cookie一般用来保存**用户信息** 比如我们在Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；Session 的主要作用就是**通过服务端记录用户的状态**。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。  
-  Cookie 数据保存在**客户端(浏览器端)**，Session 数据保存在**服务器端**。  
-  Session的运行依赖于session Id,session是存储在cookie中的，如果浏览器禁用cookie,session也会失效，但可以通过其他方式传输。  
[javaGuide/计算机网络.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)  
#### 如何防止cookie欺骗  
给cookie加密，并且加上时间戳和ip戳之类的  
## 8. 关于HTTP  
### 8.1 HTTP和HTTPS的区别  
- **HTTP报文是明文**，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是**HTTP + SSL(or TLS)**。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。  
- **端口号不同**：HTTP端口号为80，HTTPS为443
![HTTP和HTTPS区别.png](https://i.loli.net/2020/05/04/Sd1QtMhLfKYmBOc.png)
  
**关于SSL协议**  
**对称加密**： 加密和解密都使用相同的密钥  
**非对称加密**: 密钥分为私钥和公钥，公钥加密的密文只能用私钥解密，私钥加密的密文只能用公钥解密。  
非对称加密计算量很大，效率不如对称加密，通信双方通过对称加密来加密密文，然后使用非对称加密的方式来传递对称加密所使用的密钥。这样效率和安全就都能保证了。  
**SSL协议在传输层**,客户端和服务器要通过5次握手确认加密信息，具体 [阮一峰的网络日志/图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)  
  
-  客户端给出支持**SSL协议版本号**，一个**客户端随机数**(Client random，请注意这是第一个随机数)，客户端支持的**加密方法**等信息；  
-  服务器收到信息后，确认双方使用的**加密方法**，并返回**数字证书**，一个服务器**生成的随机数**(Server random，注意这是第二个随机数)等信息；  
-  客户端确认数字证书的有效性，然后**生成一个新的随机数**(Premaster secret)，然后使用数字证书中的公钥，加密这个随机数，发给服务器。  
-  服务器使用**自己的私钥**，获取客户端发来的随机数(即Premaster secret)；(第三、四步就是非对称加密的过程了)  
-  客户端和服务器通过约定的加密方法(通常是AES算法)，使用前面三个随机数，生成对话密钥，用来加密接下来的通信内容；
### 8.2 get和post的区别 
- GET用于获取信息，向特定资源发送请求，查询数据，返回身体。是无副作用的，是幂等的，且可缓存  
- POST用于修改服务器上的数据，有副作用，非幂等，不可缓存  
在讨论get和post之间的区别时候，需要分应用场景来看待：
####  浏览器中的get和post
浏览器中的即为HTTP协议中的GET/POST。浏览器使用GET请求来获取一个html页面/图片/css/js等资源；使用POST来提交一个表单，并且得到一个结果。  
浏览器中的GET/POST携带数据的格式也有区别。当浏览器发出一个GET请求时，就意味着要么用户自己浏览器输入地址，要么是点击了一个链接。并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以GET要在url之外带一些参数，就只能依靠url上附带的querystring，是HTTP协议本身并没有这个限制。  
浏览器的POST请求都来自表单提交。每次提交，表单的数据被浏览器用编码到HTTP请求的body里，url上也可以带参数。  
因此会**泛泛的说**“GET请求没有body，只有url，请求数据放在url的querystring中；POST请求的数据在body中“。但这种情况仅限于浏览器发请求的场景。

####  接口中的GET/POST
这里是指通过浏览器的Ajax api，或者iOS/Android的App的http client，java的commons-httpclient/okhttp或者是curl，postman之类的工具发出来的GET和POST请求。就没有上述的限制，只需要符合HTTP协议的规范即可。从协议本身看，并没有什么限制说GET一定不能没有body，POST就一定不能把参放到<URL>的querystring上，因此其实可以更加自由的去利用格式。但为了高效与统一，就有一些接口和规范,比如REST。

####  关于GET/POST的安全性
并不是因为GET把参数放在url中的querystring中，POST把参数放在body中就说POST就比GET更加安全。无论是GET还是POST都不够安全，因为HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。避免传输过程中数据被泄露，最通用的做法使用HTTPS。  


参考来源： [GET 和 POST 到底有什么区别？ - 大宽宽的回答 - 知乎](https://www.zhihu.com/question/28586791/answer/767316172)  
### 8.3 HTTP长连接和短连接  
  
**HTTP的长连接和短连接本质上是TCP长连接和短连接，长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况;短链接多用于访问频繁并且连接数爆炸的的情况**  
  
  
在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。    
  
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 
  

### 8.4 http请求报文和响应报文的区别  
#### HTTP请求报文  

一个HTTP请求报文由**请求行（request line）、请求头部（header）、空行和请求数据**4个部分组成。  
  
- **请求行**：请求行由**请求方法字段、URL字段和HTTP协议版本字段**3个字段组成，用空格分隔。  
  ```
  GET /index.html HTTP/1.1
  ```
  
- **请求头部**:请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息,典型的请求头有：  
  ```
  User-Agent：产生请求的浏览器类型。

  Accept：客户端可识别的内容类型列表。

  Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
  ```
    
- **空行**:最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。  
- **请求数据**: **请求数据不在GET方法中使用，而是在POST方法中使用**。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。  
  
#### HTTP报文  
HTTP响应也由三个部分组成，分别是：**状态行、消息报头、响应正文**。  
```
＜status-line＞

＜headers＞

＜blank line＞

[＜response-body＞]
```
  
**在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息**。

### 8.5 状态码  
  
![状态码](https://camo.githubusercontent.com/08ea24912a75db4a06bfd17995ce464ee4b4af48/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545372538412542362545362538302538312545372541302538312e706e67)  
常见状态代码、状态描述的说明如下：  

100：Continue --- 继续。客户端应继续其请求。

​ 200：OK --- 请求成功。一般用于GET与POST请求。

​ 301：Moved Permanently --- 永久重定向。

​ 302：Found --- 暂时重定向。

​ 400：Bad Request --- 客户端请求的语法错误，服务器无法理解。

​ 403：Forbideen --- 服务器理解请求客户端的请求，但是拒绝执行此请求。

​ 404：Not Found --- 服务器无法根据客户端的请求找到资源（网页）。

​ 500：Internal Server Error --- 服务器内部错误，无法完成请求。

​ 502：Bad Gateway --- 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。 
### 8.6 HTTP1.0，HTTP1.1，HTTPS和HTTP2.0的区别
#### HTTP1.0和HTTP1.1的一些区别
- **缓存处理**,HTTP1.1则引入了更多的缓存控制策略来控制缓存策略
- **网络连接的优化**：1.1支持断点续传
- **Host头处理**:HTTP1.1的请求消息和响应消息都应支持Host头域,且请求消息中如果没有Host头域会报告一个错误
- **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，  
  
HTTP1.0只支持3个请求方法：**GET POST HEAD**
#### HTTP2.0的新特性
- **新的二进制格式（Binary Format）**:2.0使用二进制格式
- **多路复用（MultiPlexing）**：连接共享，不同的request可以使用同一个连接传输
- **header压缩**
- **服务端推送（server push）**
[HTTP长连接、短连接究竟是什么](https://www.cnblogs.com/gotodsp/p/6366163.html)  
[JAVAGuide/计算机网络.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)
### 8.7 HTTP请求方法
- **GET**：GET请求会显示请求指定的资源，一般来说GET方法应该只用于数据的读取，GET方法是**幂等的**。GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。  
- **HEAD**: HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。  
- **POST**:POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是**非幂等**的方法，因为这个请求可能会创建新的资源或/和修改现有资源。  
- **PUT**：PUT请求会身向指定资源位置上传其最新内容，PUT方法是**幂等**的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。
- **DELETE**：DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是**幂等**的。  
- **CONNECT**：CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。  
- **OPTIONS**：OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。  
- **TRACE**：TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断
### 8.8 HTTP中的分块传输编码
**分块传输编码只在HTTP1.1中提供**  
  
  
HTTP的响应消息体 message body 是作为整包发送到客户端的，用头『Content-Length』 来表示消息体的长度， 这个长度对客户端非常重要，因为对于持久连接TCP并不会在请求完立马结束，而是可以发送多次请求/响应，客户端需要知道哪个位置才是响应消息的结束，以及后续响应的开始，因此Content-Length显得尤为重要，服务端必须精确地告诉客户端 message body 的长度是多少， 如果Content-Length 比实际返回的长度短，那么就会造成内容截断，如果比实体内容长，客户端就一直处于pendding状态，直到所有的 message body 都返回了请求才结束。    
对于一个复杂的页面来说，如果是等到消息体完全创建好之后再计算出Content-Length返回给客户端的话，在客户端那边会有一个漫长的等待过程，而对于用户来说，一个页面的所能容忍的等待时间不超过3秒，因此如何让响应内容尽可能早的让用户看到是HTTP协议要考虑的问题。  
**分块传输编码(Transfer-Encoding)**：它把数据分解成一系列数据块，并以多个块发送给客户端，服务器发送数据时不再需要预先告诉客户端发送内容的总大小，只需在响应头里面添加Transfer-Encoding: chunked，以此来告诉浏览器我使用的是分块传输编码，这样就不需要 Content-Length 了，这就是分块传输编码 Transfer-Encoding 的作用。
## 重定向和转发的区别
#### 重定向
- 地址栏发生变化
- 重定向可以访问其他服务器的资源
- 重定向是两次请求，不能使用Request对象来共享数据
#### 转发
- 转发地址栏不变
- 转发只能访问当前服务器下的资源  
- 转发是一次请求，可以使用Request对象进行共享数据
## 9. 关于RESTful
REST，即**Representational State Transfer**的缩写,可以理解为"表现层状态转化"。
表现层即为一个资源(**Resource**)的具体呈现出来的形式。  
资源是网络上的一个实体，可以用**URI**(统一资源定位符)指向它，资源可以使文本，图片等。表现层即是资源的表现形式，比如一张图片，它的表现层为png,jpg等。  
  
状态转化：即关于数据和状态的变化。在客户端和服务器之间的通信中，客户端想要服务器中的某种资源或者数据发送状态转化，那么就只能使用HTTP协议。  

如果一个架构符合REST原则，就称它为RESTful架构。RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。可以得到RESTful架构的定义如下：
  1.  每一个URI代表一种资源
  2.  客户端和服务器之间，传递这种资源的某种表现层
  3.  客户端通过HTTP协议，对服务器端资源进行操作，实现"表现层状态转化"。  
  
来源：[阮一峰-理解RESTful架构](https://www.ruanyifeng.com/blog/2011/09/restful.html)
关于RESTful的架构的api的实践原则： [阮一峰-RESTful API 最佳实践](https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html)  
  

  
## 10. URI和URL的区别  
- URI(Uniform Resource Identifier) 是**统一资源标志符**，可以唯一标识一个资源  
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源

 
## TCP如何保证可靠性
都说Tcp协议是可靠的，那tcp是如何保证可靠的？  
TCP通过**序列号、确认应答、重传机制、滑动窗口、流量控制和拥塞控制**来保证可靠性。其中序列号和确认应答就是给包编上序号，接收方收到包后要返回确认包给发送方  
![2.PNG](https://i.loli.net/2020/09/02/tboqkGSn7C2fO3E.png)
  
[你还在为 TCP 重传、滑动窗口、流量控制、拥塞控制发愁吗？一文搞定！](https://mp.weixin.qq.com/s/xe3dEu17mGTqM46LRFxzhg)
### 重传机制
TCP针对数据包丢失的情况，会采用**重传机制**解决，重传机制包括下面四种
#### 超时重传  
  
就是在发送数据时，设定一个定时器，当超过指定的时间(RTT)后，没有收到对方的 ACK 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**。
超时重传需要计算**RTO(超时重传时间)**，RTO是根据RTT计算的，ROT应该略微大于报文往返时间RTT。由于我们的网络是时常发生变化的，所以RTT是变化的，那RTO也是动态变化的。RTO是需要TCP采样RTT时间和RTT波动范围，然后根据公式进行计算  
  
**如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP的策略是超时间隔加倍**。  
也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送  
  
  
超时触发重传存在的问题是，超时周期可能相对较长
#### 快速重传
![3.PNG](https://i.loli.net/2020/09/02/oCBjA8I7KapJg2W.png)
如上图所示，发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。  
最后接收到了seq2,Seq3，Seq4，Seq5 都收到了,所以ack会返回seq6  
  
**快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。**   
  
快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，**是重传之前的一个，还是重传所有的问题**。


#### SACK

这种方式需要在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将**缓存的地图发送给发送方**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。
  
![640.png](https://i.loli.net/2020/09/02/oPuGcz1FEamjepi.png)  

发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。  

#### D-SACK
D-SACK也就是Duplicate SACK，就是接受方告诉发送方哪些包重复接受了。会出现两种情况
- ACK丢包
  ![640 (1).png](https://i.loli.net/2020/09/02/oWbwPCe4EtYqrp5.png)
  - 接收方发给发送方的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）  
  - 于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK
    
- 网络延时
  ![640 (2).png](https://i.loli.net/2020/09/02/M3jtbrBYxgVqRTW.png)
  - 数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。

  - 而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；

  - 所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。

  - 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。
