<!-- TOC -->
- [进程和线程的区别](#进程和线程的区别)   
- [进程的状态](#进程的状态)  
- [进程间通讯](#进程间通讯)  
- [进程调度算法](#进程调度算法)  
- [线程间同步](#线程间同步)  
- [进程内存的分配](#进程内存的分配)  
- [IO模型](#IO模型)  
- [操作系统内存管理机制](#操作系统内存管理机制)
- [linux常见命令](#linux常见命令)

基本参考[JavaGuide](https://github.com/Snailclimb/JavaGuide/tree/master/docs/operating-system)
##  进程和线程的区别
**进程**  
进程是程序的一次执行过程,是动态的,是程序执行过程中分配和管理资源的基本单位。系统运行一个程序即是一个进程从创建，运行到消亡的过程。  
**线程**  
线程是进程划分为更小的运行单位，线程也被称为轻量级进程。它是cpu调度和执行的基本单位。  
**总结**  
一个进程在执行过程中可以产生多个线程。线程和进程的最大区别是基本上各进程是独立的，而线程不一样，同属于一个进程的线程极大可能受影响。线程执行开销小，不利于资源的管理和保护，进程则相反。
##  进程的状态  
- 创建状态：进程正在创建  
- 就绪状态：进程已经准备好运行，即进程获得了除处理器以外的其他  
- 运行状态：进程正在运行    
- 阻塞状态：进程在等待某一事件而暂停运行    
- 结束状态：进程结束运行
## 进程间通讯  
- **管道/匿名管道(pipe)**:半双工通讯，只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)  
- **有名管道(FIFO)**：有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信，即不需要血缘关系。  
- **信号(Signal)**：用于通知接收进程某个事件已经发生.  
- **消息队列(Message Queuing)**:消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识,消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
- **信号量(Semaphores)**:信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。  
- **共享内存(Shared memory)**：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新  
- **套接字(Sockets)**：此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程
## 进程调度算法  
1. **先到先服务(FCFS)调度算法**:从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。  
2. **短作业优先(SJF)的调度算法**:从就绪队列中选出一个估计运行时间最短的进程为之分配资源  
3. **时间片轮转调度算法**：每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。  
4. **多级反馈队列**：多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成  
5. **优先级调度**：为每个流程分配优先级，首先执行具有最高优先级的进程
## 线程间同步  
互斥量(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
信号量(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操
## 进程内存的分配
每个进程所分配的内存由很多部分组成，通常称之为**段**：
- **文本段**：包含了进程运行的程序机器语言指令。文本段具有只读属性
- **数据段**： 包含**初始化数据段和未初始化数据段**，初始化数据段显示初始化的全局变量和静态变量，未初始化段则显示未初始化的
- **栈**：由栈帧组成，为每一个函数的执行分配一个栈帧
- **堆**：运行时动态进行内存分配的一块区域
#### 父子进程内存的关系
文本段是只读的，因此父进程和子进程都指向同一地址，数据段、堆段、栈段则是不同的。
## 用户态和内核态
在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意的破坏，限制不同程序的访问能力，计算机设置了两种状态：用户态、内核态。  
**用户态**：只能受限的访问内存，运行应用程序  
**内核态**：运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备
#### 用户态切换到内核态的3种方式  
- **系统调用**：用户进程主动切换到内核态的一种方式
- **异常**：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常  
- **外围设备中断**：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。
## 死锁  
死锁指两个或两个以上的进程执行过程中，因争夺资源造成互相等待的现象。**解决方法**：破坏死锁的任意一条件
#### 死锁的条件
- 互斥条件：一个资源每次只能被一个进程使用
- 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放
- 不可强行占有：进程已获得的资源，在末使用完之前，不能强行剥夺
- 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系
## IO模型  
linux/unix中有五种IO模型，5种IO模型分别是阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型、异步IO模型；前4种为同步IO操作，只有异步IO模型是异步IO操作。
-  **阻塞IO模型**
进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。  
典型应用：**阻塞Socket,Java BIO**
特点：  
  - 进程阻塞挂起不消耗CPU资源，及时响应每个操作；
  - 实现难度低、开发应用较容易；
  - 适用并发量小的网络应用开发；
- **非阻塞IO模型** 
进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。  
典型应用：**socket是非阻塞的方式（设置为NONBLOCK）**  
特点：  
   - 进程轮询（重复）调用，消耗CPU的资源；
   - 实现难度低、开发应用相对阻塞IO模式较难；
-  **IO复用模型**
多个的进程的IO可以注册到一个**复用器（select）**上，然后用一个进程调用该select， select会监听所有注册进来的IO；如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回  
典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;Java NIO;  
- **信号驱动IO模型**  
当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。  
- **异步IO模型**  
当进程发起一个IO操作，进程返回（不阻塞），但也不能返回结果；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。  
典型应用：Java AIO、高性能服务器应用
## 操作系统内存管理机制
操作系统的内存管理主要负责内存的分配与回收，另外地址转换(将逻辑地址转化为物理地址)也是操作系统内存管理。
#### 内存管理机制
- 连续分配管理方式
  -  块式管理：将内存划分为大小相等的块，容易产生内存浪费与内存碎片
- 非连续分配管理方式
  - **页式管理**：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚较⼩，相对相⽐于块式管理的划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过⻚表对应逻辑地址和物理地址
  - **段式管理**：段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多
  - **段页式管理**： 段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚
#### 分页机制和分段机制的共同的区别：
- 共同点：  
   - 分页和分段都是提高内存利用率，减少内存碎片
   - 页和段都是离散存储的，两者都是离散分配内存的方式
- 区别：
   - 页的大小是固定的，段的大小不固定，取决于当前运行的程序
   - 分页是为了满足操作系统内存管理的需求，分段是逻辑信息的单位
#### 局部性原理
局部性原理是虚拟内存技术的基础，正是因为程序运⾏具有局部性原理，才可以只装⼊部分程序到内存就开始运⾏。主要包括以下两个方面：
- **时间局部性**：即大多数时间访问指令
- **空间局部性**：即大多数访问某些地址
时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并且使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到⾼速缓存控制逻辑中实现。
## 中断
 程序执行过程中CPU会遇到一些特殊情况，是正在执行的程序被“中断”，cpu中止原来正在执行的程序，转到处理异常情况或特殊事件的程序去执行，结束后再返回到原被中止的程序处(断点)继续执行
 - **可屏蔽中断**：可通过设置屏蔽字来屏蔽请求，若中断请求被屏蔽，则不会被送到CPU
 - **不可屏蔽中断**：非常紧急的硬件中断，如：电源掉电，硬件线路故障等。一旦产生，就被立即送CPU，以便快速处理
## linux常见命令  
### 目录
- ```cd ~```:切换目录
- ```mkdir 目录名称```:创建目录
- ```ls或者ll```:查看目录信息和所有文件信息  
- ```find 目录 参数```:寻找目录（查）  
    - 列出当前目录及子目录下所有文件和文件夹: `find .`
    - 在`/home`目录下查找以.txt结尾的文件名:`find /home -name "*.txt"`
    - 同上，但忽略大小写: `find /home -iname "*.txt"`
    - 当前目录及子目录下查找所有以.txt和.pdf结尾的文件:`find . \( -name "*.txt" -o -name "*.pdf" \)`或`find . -name "*.txt" -o -name "*.pdf" ` 
-  **`mv 目录名称 新目录名称`：** 修改目录的名称  
-  **`mv 目录名称 目录的新位置`：**  移动目录的位置  
-  **`cp -r 目录名称 目录拷贝的目标位置`：** 拷贝目录（改），-r代表递归拷贝 
-  **`rm [-rf] 目录`:** 删除目录（删）
### 文件  
-  **`touch 文件名称`:**  文件的创建  
-  **`cat/more/less/tail 文件名称`** 文件的查看（查）
    - **`cat`：** 查看显示文件内容
    - **`more`：** 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看
    - **`less`：** 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看
    - **`tail-10` ：** 查看文件的后10行，Ctrl+C结束
- **`vim 文件`：**  修改文件的内容（改）  
- **`rm -rf 文件`：** 删除文件  
- **`chmod`**：**修改文件/目录的权限的命令
### 压缩
- **`tar -zcvf 打包压缩后的文件名 要打包压缩的文件`**  
- **`tar [-xvf] 解压文件名 解压后文件目录`**
### 用户  
- **`useradd 选项 用户名`**:添加用户账号
- **`userdel 选项 用户名`**:删除用户帐号
- **`usermod 选项 用户名`**:修改帐号
- **`passwd 用户名`**:更改或创建用户的密码
- **`passwd -S 用户名` **:显示用户账号密码信息
- **`passwd -d 用户名`**:  清除用户密码
### 进程
- **`ps -ef`/`ps -aux`：** 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同
  如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。
- **`ps -ef|grep 进程名`:** ps通常与grep联合使用，用户查看系统中是否有相关进程，如`ps -ef|grep redis` 查看redis进程
- **`top`**: 实时显示系统中各个进程的资源占用状况
- **`jps`**: jps是jdk提供的一个查看当前java进程
-  **`kill -9 进程的pid`：** 杀死进程
