## 1. 关于BFS
## 2. 关于DFS
DFS就是深度优先遍历，从一个节点出发，使用 DFS 对一个图进行遍历时，能够遍历到的节点都是从初始节点可达的，DFS 常用来求解这种 可达性 问题。  
一般DFS的题目都是针对图(也就是给你一个矩阵)，要求得到最大连通面积或者连通数量等。需要注意如下事项：  
  
  -  需要对遍历过的节点进行标记，设置一个hasVisited数组或者是将经过的点设置为矩阵中的某个值
  -  注意方向，如果表明垂直和水平，则为4个方向，如果还包括斜方向，则为8个方向。
  -  如果给的图为正方形，且各个节点的连通具有传递性 a<->b, b<->c 可以得出 a<->c(比如朋友圈)，那么不需要方向。
      ```
      四个方向：int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
      八个方向：int[][] direction = {{1, -1}, {1, 0}, {1, 1}, {0, -1}, {0, 1}, {-1, -1}, {-1, 0}, {-1, 1}};
      ```
代码框架
```
class{
  int m,n;//矩阵长短
  int[][] directions;//方向
  
  def main(矩阵){
    m=...
    n=...
    
    初始化访问数组
    
    for(){
       for(){
         调用dfs方法
       }
    }
  }
  def dfs(int i,int j,hasvisited,矩阵){
      if(传入参数i,j越界判断,是否访问判断，是否相同判断) return ...;
      hasvisited[i][j]=true;
      for(int[] direction:directions){
      //每个方向遍历
      }
  }
}

```

相关提集：[CyC2018/CS-Notes/Leetcode dfs题解](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#dfs)

## 3. 回溯算法
 Backtracking(回溯) 主要用于求解**排列组合**问题,回溯算法有固定的的框架，
 ```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
 ```
 如果求排列组合，也就是有多少种结果，例如[IP 地址划分](https://leetcode-cn.com/problems/restore-ip-addresses/description/)等，backtrack方法的参数一般都为下面的样式
 ```
 void backtrack(当前决策树层数,临时存储数据,题目给的参数，最终返回的结果)
 //如下所示
 void backtracking(int k,StringBuilder sb,String s,  List<String> res)
 ```
 如果像dfs那样是否能找到一条路径，那么就设置为 boolean backtrack
