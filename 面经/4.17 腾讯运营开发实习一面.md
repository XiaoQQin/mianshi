# java 1.8 和 1.7的区别 (java 基础)
1.  **lambda表达式**：可以将函数作为参数传递进方法中，使代码更加简洁，可以简化匿名内部类的书写，但是这个匿名内部类必须是个函数接口。比如线程的创建runnable
2.  **方法引用**： 通过方法的名字来指向一个方法,使用双冒号 :: .比如 System.out:println
3.  **函数接口**： 是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。可以转化为lambda表达式
4.  **引入Stream**: 函数式编程的核心，类似于spark RDD。有中间操作和结束操作 类似于spark的transformer 和 action.
# Java Lambda 表达式 (java 基础)
 lambda 是java 1.8的新特性，允许把函数作为方法的参数，即 函数作为参数传递进方法中。lambda可以是java代码更加紧凑，简洁.有以下特征:
 1. **可选类型声明**: 即可以不需要声明传入参数的类型
 2. **可选参数圆括号**：如果只有一个参数可以不需要圆括号，多个参数就需要圆括号
 3. **可选择的大括号**：如果函数内部只有一条语句，可以不用大括号
 4. **可选择返回关键字**：即函数内部只有一条语句，不需要使用return 返回，如果函数体使用大括号的话就一定要使用return
 
 能够使用Lambda的依据:  
 1. 必须有相应的函数接口（函数接口，是指内部只有一个抽象方法的接口）
 2. Lambda表达式另一个依据是类型推断机制，在上下文信息足够的情况下，编译器可以推断出参数表的类型，而不需要显式指名
 ### 关于lambda内部的变量作用域：  
     1.不能修改在外部已经定义的变量，只可以应用使用 final 关键字 定义的变量
     2.可以直接在 lambda 表达式中访问外层的局部变量
     3.Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量
 ### 关于lambda和匿名内部类的区别
  1.  匿名内部类仍然是一个类，只是不需要程序员显示指定类名，编译器会自动为该类取名.编译之后将会产生两个class文件
  2.  Lambda表达式通过invokedynamic指令实现，书写Lambda表达式不会产生新的类.编译之后只有一个class文件
   
    
  **推荐链接**：[关于Java Lambda表达式和java stream看这一篇就够了](https://objcoding.com/2019/03/04/lambda/)
# int 和 Integer 区别 (java 基础)
  1.  int是基本类型，Integer是int的封装类,要把Integer当做一个类使用
  2.  int和Integer都可以表示某一数值
  3.  因为有自动装箱和拆箱，Integer i=2,即Integer对象可以直接赋值
# get 和 post 的区别 (java web)
  在讨论get和post之间的区别时候，需要分应用场景来看待：
   ###  浏览器中的get和post
  浏览器中的即为HTTP协议中的GET/POST。浏览器使用GET请求来获取一个html页面/图片/css/js等资源；使用POST来提交一个表单，并且得到一个结果。  
  浏览器中的GET/POST携带数据的格式也有区别。当浏览器发出一个GET请求时，就意味着要么用户自己浏览器输入地址，要么是点击了一个链接。并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以GET要在url之外带一些参数，就只能依靠url上附带的querystring，是HTTP协议本身并没有这个限制。  
  浏览器的POST请求都来自表单提交。每次提交，表单的数据被浏览器用编码到HTTP请求的body里，url上也可以带参数。  
  因此会**泛泛的说**“GET请求没有body，只有url，请求数据放在url的querystring中；POST请求的数据在body中“。但这种情况仅限于浏览器发请求的场景。
  
  ###  接口中的GET/POST
  这里是指通过浏览器的Ajax api，或者iOS/Android的App的http client，java的commons-httpclient/okhttp或者是curl，postman之类的工具发出来的GET和POST请求。就没有上述的限制，只需要符合HTTP协议的规范即可。从协议本身看，并没有什么限制说GET一定不能没有body，POST就一定不能把参放到<URL>的querystring上，因此其实可以更加自由的去利用格式。但为了高效与统一，就有一些接口和规范,比如REST。
 
 ###  关于GET/POST的安全性
 并不是因为GET把参数放在url中的querystring中，POST把参数放在body中就说POST就比GET更加安全。无论是GET还是POST都不够安全，因为HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。避免传输过程中数据被泄露，最通用的做法使用HTTPS。  
   
     
 参考来源： [GET 和 POST 到底有什么区别？ - 大宽宽的回答 - 知乎](https://www.zhihu.com/question/28586791/answer/767316172)
# 是否了解 RESTful   (java web)
REST，即**Representational State Transfer**的缩写,可以理解为"表现层状态转化"。
表现层即为一个资源(**Resource**)的具体呈现出来的形式。  
资源是网络上的一个实体，可以用**URI**(统一资源定位符)指向它，资源可以使文本，图片等。表现层即是资源的表现形式，比如一张图片，它的表现层为png,jpg等。  
  
状态转化：即关于数据和状态的变化。在客户端和服务器之间的通信中，客户端想要服务器中的某种资源或者数据发送状态转化，那么就只能使用HTTP协议。  

如果一个架构符合REST原则，就称它为RESTful架构。RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。可以得到RESTful架构的定义如下：
  1.  每一个URI代表一种资源
  2.  客户端和服务器之间，传递这种资源的某种表现层
  3.  客户端通过HTTP协议，对服务器端资源进行操作，实现"表现层状态转化"。  
  
来源：[阮一峰-理解RESTful架构](https://www.ruanyifeng.com/blog/2011/09/restful.html)
关于RESTful的架构的api的实践原则： [阮一峰-RESTful API 最佳实践](https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html)
# kafka 如果一个broker宕机会发生什么？(带数据)
当kafka的一个broker,是不会将宕机掉的broker上的数据复制到其他broker上。通常情况下，如果broker没有彻底坏，请快速启动，复制数据是很浪费的。在更罕见的情况下，可以重新启动一个broker,并且将它的broker id设置为宕机broker的id,那么新的broker将会自动复制缺失的数据。  

[来源](https://cwiki.apache.org/confluence/display/KAFKA/FAQ#FAQ-Howtoreplaceafailedbroker?)
# 编程题(带数据)： acess.log 里面每一行第一列是ip,后面是访问的其他信息，编写程序，统计日志文件里面ip的频次，并去除topK 频次最高的ip,文件大小50G.
以下代码是没有经过文件切割与考虑文件大小的，只供参考。
```
        String filename="access.log";

        BufferedReader bufferedReader=null;
        bufferedReader=new BufferedReader(new InputStreamReader(new FileInputStream(filename)));
        String line;
        //对
        int k=2;
        PriorityQueue<String> queue=new PriorityQueue<>(k);
        Map<String,Integer> map=new HashMap<>();
        Map<String,Integer> total=new HashMap<>();
        while((line=bufferedReader.readLine())!=null){
            String ip=line.split(" ")[0];
            map.put(ip,map.getOrDefault(ip,0)+1);
            

        }

        map.forEach((String str1,Integer value)->{
            if(queue.size()<k){
                queue.offer(str1);
            }
            else if(value>map.get(queue.peek())){
                queue.poll();
                queue.offer(str1);
            }

        });

        while (!queue.isEmpty()){
            System.out.println(queue.poll());
        }
```
