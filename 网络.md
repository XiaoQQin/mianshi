<!-- TOC -->
- [1. OSI与TCP/IP网络模型](#1-OSI与TCP/IP网络模型)  
  - [1.1 OSI七层模型](#11-OSI七层模型)  
  - [1.2 TCP/IP五层模型](#12-TCP/IP五层模型)  
- [2. TCP三次握手与四次挥手](#2-TCP三次握手与四次挥手)  
  - [2.1 TCP三次握手](#21-TCP三次握手)  
  - [2.2 四次挥手](#22-四次挥手)  
- [3. TCP和UDP协议的区别](#3-TCP和UDP协议的区别)  
- [4. 从输入URL到页面加载发生了什么](#4-从输入URL到页面加载发生了什么)  
- [5. Cookie和Session](#5-Cookie和Session)  
- [6. 关于HTTP](#6-关于HTTP)  
  - [6.1 HTTP和HTTPS的区别](#61-HTTP和HTTPS的区别)  
  - [6.2 get和post的区别(java_web)](#62-get和post的区别(java_web))  
  - [6.3 HTTP长连接和短连接](#63-HTTP长连接和短连接)  
  - [6.4 http请求报文和响应报文的区别](#64-http请求报文和响应报文的区别)  
  - [6.5 状态码](#64-状态码)  
- [7. 关于RESTful(java_web)](#7-关于RESTful(java_web))  
- [8. URI和URL的区别](#8-URI和URL的区别)  
- [9. TCP流量控制和拥塞控制](#9-TCP流量控制和拥塞控制)  
  - [9.1 流量控制](#91-流量控制)  
  - [9.2 拥塞控制](#92-拥塞控制)  
  - [9.3 流量控制和拥塞控制的区别](#93-流量控制和拥塞控制的区别)
<!-- /TOC -->
## 1. OSI与TCP/IP网络模型
### 1.1 OSI七层模型
![osi七层模型](https://user-gold-cdn.xitu.io/2019/8/31/16ce7c55e2003c1b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
### 1.2 TCP/IP五层模型  
其实TCP/IP只有4层，包括：**应用层、传输层、网络互连层、网络链接层**，但是综合OSI七层模型，我们一般称作5层，所以平时称TCP/IP五层模型也没错。  
![tcp/ip五层模型](https://user-gold-cdn.xitu.io/2019/8/31/16ce7e7fe7d7c181?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
  
- **应用层**:为应用程序提供网络服务。在互联网中应用层协议很多，如域名系统**DNS**，支持万维网应用的**HTTP协议**，支持电子邮件的**SMTP协议**等等。我们把应用层交互的数据单元称为**报文**。 
  

- **传输层**:负责向两台主机进程之间的通信提供通用的数据传输服务,也就是我们所说的端对端传输。  
   运输层主要使用以下两种协议：  
      - **TCP**：提供面向连接的，可靠的数据传输服务。  
      - **UDP**：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。
  
- **网络层**：网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。也就是ip寻址、路由选择和数据传输。网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。  
  
- **数据链路层**： 控制网络层和物理层之间的通信，提供介质访问和链路管理。物理寻址，将原始比特流传输转变为逻辑传输路线。  
  
- **物理层**: 原始比特流的传输
  
### 网络模型的设备和协议  
在网络模型的每一层都工作着不同的设备，，如下图所示：  
![设备工作](https://user-gold-cdn.xitu.io/2019/8/31/16ce7eb72c0dc44c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
  
每一层的主要协议如下所示：  
  
![协议](https://user-gold-cdn.xitu.io/2019/8/31/16ce7ee86d166933?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)  
  
通常需要注意以下协议；  
- **HTTP、HTTPS在应用层**
- **TCP、UDP在传输层**  
- **IP在网络层**
  
    
[JavaGuide/计算机网络](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)        
[网络模型--OSI & TCP/IP](https://juejin.im/post/5d398dc26fb9a07ecb0bedde)
  
  
## 2. TCP三次握手与四次挥手
### 2.1 TCP三次握手  
    
![三次握手.PNG](https://i.loli.net/2020/05/04/1kURADPvgrYObF2.png)
![TCP三次握手](https://camo.githubusercontent.com/f6dfce1f05e95f94dbcc4b0bee8c4e3acbfb9f30/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67)  
  
**简单描述**:  
  
  - 客户端发送带有**SYN**标志的数据包，一次握手  
  - 服务器发送带有**SYN/ACK**标志的数据包，二次握手  
  - 客户端发送带有**ACK**标志的数据包，三次握手  
  
#### 为什么要三次握手？  
  
三次握手的目的是建立可靠的通信信道,三次握手就是双方确认自己与对方的发送与接收是正常的。  
  
- 第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常
- 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接受正常；Server确认了：对方发送正常，自己接受正常  
- 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接受正常：Server确认了：对方发送正常、接收正常，自己发送、接受正常。  
  
 所以三次握手就能确认客户端和服务器收发功能都正常，缺一不可。  
   
#### 第2次握手传回了ACK，为什么还要传回SYN？  
服务器回传给客户端SYN是为了**建立并确认从服务端到客户端的通信**。  

#### 两次握手会怎么样？  
有这样一种情况，当A发送一个消息给B，但是由于网络原因，消息被阻塞在了某个节点，然后阻塞的时间超出设定的时间，A会认为这个消息丢失了，然后重新发送消息。 
    
 
当A和B通信完成后，这个被A认为失效的消息，到达了B。对于B而言，以为这是一个新的请求链接消息，就向A发送确认;对于A而言，它认为没有给B再次发送消息（因为上次的通话已经结束）所有A不会理睬B的这个确认，但是B则会一直等待A的消息。  
这就导致了B的时间被浪费（对于服务器而言，CPU等资源是一种浪费），这样是不可行的，这就是为什么不能两次握手的原因了。

二次握手会出现**已失效的请求报文段突然又传送到了服务端而产生连接的误判**的情况。三次握手就是防止已失效的请求报文段突然又传送到了服务端而产生连接的误判，也就是防止服务器资源因为错误数据而一直等待，浪费资源。
[TCP为什么是三次握手和四次挥手](https://blog.csdn.net/yu876876/article/details/81560122)
### 2.2 四次挥手  
![四次挥手.png](https://i.loli.net/2020/05/04/yAmKi32XvsnSJHz.png)    
![四次挥手](https://camo.githubusercontent.com/66e3447783e22d736f7db9c7d121e8eba54f07c0/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f5443502545352539422539422545362541432541312545362538432541352545362538392538422e706e67)
  
**简要描述**：  
  - 客户端发送一个**FIN**，用来关闭客户端到服务器的数据传输  
  - 服务器接收到这个**FIN**,他发回一个**ACK**，确认的序号为收到的序号加1。  
  - 服务器关闭与客户端的链接，发送一个**FIN**给客户端  
  - 客户端发回**ACK**报文确认，确认序号设置为收到序号加1。  
    
 #### 为什么要四次挥手？  
TCP是全双工模式，客户端和服务器都可以发送和接受数据。这就意味着，当客户端发出FIN报文段时，只是表示客户端已经没有数据要发送了，客户端告诉服务器，它的数据已经全部发送完毕了；但是，这个时候客户端还是可以接受来自服务器的数据；当服务器返回ACK报文段时，表示它已经知道客户端没有数据发送了，但是服务器还是可以发送数据到客户端的；当服务器也发送了FIN报文段时，这个时候就表示服务器也没有数据要发送了。  
  
  
## 3. TCP和UDP协议的区别  
![tcp和udp的区别](https://camo.githubusercontent.com/582cf0bd58f1b7859ff7696d0345200d133bee88/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f7463702d76732d7564702e6a7067)
- TCP是面向连接，可靠传输的;UDP是面向无连接，传输不可靠的。  
- TCP传输效率更慢，UDP传输更快  
- TCP一般应用在要求数据传输可靠的场景，比如邮件传输，远程登录；UDP一般应用在要求传输速度快的场景，比如视频会议，语音通话。  
  
## 4. 从输入URL到页面加载发生了什么  
- **DNS解析**:DNS解析的过程就是寻找哪台机器上有你需要资源的过程，实现了网址到IP地址的转换,DNS解析是一个递归查询的过程。  
- **TCP连接**: 三次握手  
- **发送HTTP请求**  
- **服务器处理请求并返回HTTP报文**  
- **浏览器解析渲染页面**
- **连接结束**  
  
具体请看：[前端经典面试题: 从输入URL到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)  
  
## 5. Cookie和Session  
  
-  Cookie一般用来保存**用户信息** 比如我们在Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；Session 的主要作用就是**通过服务端记录用户的状态**。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。  
-  Cookie 数据保存在**客户端(浏览器端)**，Session 数据保存在**服务器端**。  
-  Session的运行依赖于session Id,session是存储在cookie中的，如果浏览器禁用cookie,session也会失效，但可以通过其他方式传输。  
[javaGuide/计算机网络.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)  
#### 如何防止cookie欺骗  
给cookie加密，并且加上时间戳和ip戳之类的  
## 6. 关于HTTP  
### 6.1 HTTP和HTTPS的区别  
**HTTP报文是明文**，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是**HTTP + SSL(or TLS)**。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。  
  
![http和https的区别](https://segmentfault.com/img/bVp65j)  
  
**关于SSL协议**  
  
客户端和服务器要通过5次握手确认加密信息，具体 [阮一峰的网络日志/图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)
  
### 6.2 get和post的区别(java_web)
在讨论get和post之间的区别时候，需要分应用场景来看待：
####  浏览器中的get和post
浏览器中的即为HTTP协议中的GET/POST。浏览器使用GET请求来获取一个html页面/图片/css/js等资源；使用POST来提交一个表单，并且得到一个结果。  
浏览器中的GET/POST携带数据的格式也有区别。当浏览器发出一个GET请求时，就意味着要么用户自己浏览器输入地址，要么是点击了一个链接。并不是GET只能用url，而是浏览器直接发出的GET只能由一个url触发。所以GET要在url之外带一些参数，就只能依靠url上附带的querystring，是HTTP协议本身并没有这个限制。  
浏览器的POST请求都来自表单提交。每次提交，表单的数据被浏览器用编码到HTTP请求的body里，url上也可以带参数。  
因此会**泛泛的说**“GET请求没有body，只有url，请求数据放在url的querystring中；POST请求的数据在body中“。但这种情况仅限于浏览器发请求的场景。

####  接口中的GET/POST
这里是指通过浏览器的Ajax api，或者iOS/Android的App的http client，java的commons-httpclient/okhttp或者是curl，postman之类的工具发出来的GET和POST请求。就没有上述的限制，只需要符合HTTP协议的规范即可。从协议本身看，并没有什么限制说GET一定不能没有body，POST就一定不能把参放到<URL>的querystring上，因此其实可以更加自由的去利用格式。但为了高效与统一，就有一些接口和规范,比如REST。

####  关于GET/POST的安全性
并不是因为GET把参数放在url中的querystring中，POST把参数放在body中就说POST就比GET更加安全。无论是GET还是POST都不够安全，因为HTTP本身是明文协议。每个HTTP请求和返回的每个byte都会在网络上明文传播，不管是url，header还是body。避免传输过程中数据被泄露，最通用的做法使用HTTPS。  


参考来源： [GET 和 POST 到底有什么区别？ - 大宽宽的回答 - 知乎](https://www.zhihu.com/question/28586791/answer/767316172)  
### 6.3 HTTP长连接和短连接  
  
**HTTP的长连接和短连接本质上是TCP长连接和短连接，长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况;短链接多用于访问频繁并且连接数爆炸的的情况**  
  
  
在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。    
  
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 
  

### 6.4 http请求报文和响应报文的区别  
#### HTTP请求报文  

一个HTTP请求报文由**请求行（request line）、请求头部（header）、空行和请求数据**4个部分组成。  
  
- **请求行**：请求行由**请求方法字段、URL字段和HTTP协议版本字段**3个字段组成，用空格分隔。  
  ```
  GET /index.html HTTP/1.1
  ```
  
- **请求头部**:请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息,典型的请求头有：  
  ```
  User-Agent：产生请求的浏览器类型。

  Accept：客户端可识别的内容类型列表。

  Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。
  ```
    
- **空行**:最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。  
- **请求数据**: **请求数据不在GET方法中使用，而是在POST方法中使用**。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。  
  
#### HTTP报文  
HTTP响应也由三个部分组成，分别是：**状态行、消息报头、响应正文**。  
```
＜status-line＞

＜headers＞

＜blank line＞

[＜response-body＞]
```
  
**在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息**。

### 6.5 状态码  
  
![状态码](https://camo.githubusercontent.com/08ea24912a75db4a06bfd17995ce464ee4b4af48/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f2545372538412542362545362538302538312545372541302538312e706e67)  
常见状态代码、状态描述的说明如下：  
-  200 OK：客户端请求成功。
-  400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
-  401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。
-  403 Forbidden：服务器收到请求，但是拒绝提供服务。
-  404 Not Found：请求资源不存在，举个例子：输入了错误的URL。
-  500 Internal Server Error：服务器发生不可预期的错误。
-  503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF)  
  
  
[HTTP长连接、短连接究竟是什么](https://www.cnblogs.com/gotodsp/p/6366163.html)  
[JAVAGuide/计算机网络.md](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)
## 7. 关于RESTful(java_web)
REST，即**Representational State Transfer**的缩写,可以理解为"表现层状态转化"。
表现层即为一个资源(**Resource**)的具体呈现出来的形式。  
资源是网络上的一个实体，可以用**URI**(统一资源定位符)指向它，资源可以使文本，图片等。表现层即是资源的表现形式，比如一张图片，它的表现层为png,jpg等。  
  
状态转化：即关于数据和状态的变化。在客户端和服务器之间的通信中，客户端想要服务器中的某种资源或者数据发送状态转化，那么就只能使用HTTP协议。  

如果一个架构符合REST原则，就称它为RESTful架构。RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。可以得到RESTful架构的定义如下：
  1.  每一个URI代表一种资源
  2.  客户端和服务器之间，传递这种资源的某种表现层
  3.  客户端通过HTTP协议，对服务器端资源进行操作，实现"表现层状态转化"。  
  
来源：[阮一峰-理解RESTful架构](https://www.ruanyifeng.com/blog/2011/09/restful.html)
关于RESTful的架构的api的实践原则： [阮一峰-RESTful API 最佳实践](https://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html)  
  

  
## 8. URI和URL的区别  
- URI(Uniform Resource Identifier) 是**统一资源标志符**，可以唯一标识一个资源  
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源

  
## 9. TCP流量控制和拥塞控制  

### 9.1 流量控制  
如果发送方把数据发送的过快，接收方来不及接收，就会造成数据丢失。流量控制即让发送方的数据不要发送的太快，要让接收方来得及接收。  
使用**滑动窗口机制**可以实现TCP的流量控制，根据期望接收的下一字节序号与当前窗口大小来控制发送端发送的字节数。    
  
假设期望接收下一字节的序号为n,当前已发送的字节序号为x,窗口大小为m, 则可以发送的字节数```y=m-(x-n)```  
  
### 9.2 拥塞控制
如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高，有四种方法可以进行拥塞控制
  
#### 1.慢开始与拥塞避免
发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...  

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。  

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。  

#### 2.快重传与快恢复
在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。  

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。  

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。  

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。  

   
### 9.3 流量控制和拥塞控制的区别

- **流量控制**：流量控制作用于接受者，控制发送者的发送速度而使接受者来得及接收，防止分组丢失  
- **拥塞控制**：拥塞控制作用于网络，防止过多的数据注入到网络中，降低整个网络的拥塞程度。
  
[CyC2018/CS-Notes/传输层.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.md#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
