#   1. Integer对象的==和equals，Integer缓冲池
关于Integer这个类，它是重写了equals方法的，比较的是两个Intger对象的值是否相同。  
如果将一个整型直接赋值给一个Integer对象，会发生自动装箱，比如： Integer a=200。它相当于 Integer a=Integer.valueOf(200).下面valueOf方法的源代码：  
```
public static Integer valueOf(int i) {  
  assert IntegerCache.high >= 127;  
  if (i >= IntegerCache.low && i <= IntegerCache.high)  
    return IntegerCache.cache[i + (-IntegerCache.low)];  
  return new Integer(i);  
}
```
可以看到有一个IntegerCache，默认IntegerCache.low 是-127，Integer.high是128，如果参数中的i在这个范围之内，则返回一个数组中的内容，
如果不在这个范围，则new一个新的Integer对象并返回。  

两个自动装箱的变量，但是装箱传递的值大于127，比如 Integer a=200,b=200; a==b; 那么a==b 就会返回false。因为值不在-128-127这个返回，如果在这个范围那么返回的是true.
自动拆箱是一个整型和一个Integer对象进行比较如： int a=200;Integer b=200; a==b; 那么b就会自动拆箱调用**intValue**方法，得到对象里的值再进行比较。  
当一个整型传入Integer对象的equals方法里，也会发生自动装箱，java会自动将这个值打包装箱为Integer类。  

因此可以得出：  
 1). Integer类里的equals方法是重写过的，比较的是值  
 2). 发生自动装箱，那么要根据传入的值进行判断，如果不在[-128,127]这个范围，就会new一个Integer对象.  

[java基础中Integer值用==和equals判断相等问题解析](https://blog.csdn.net/w112736112736/article/details/77986283)
    
#   2. volatile和synorized关键字
在Java虚拟机规范中试图定义一种Java内存模型(**JMM**),来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。  
Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。  
如果一个程序想要并发的执行，那么必须保证原子性、可见性、一致性。   
  
  
**原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。  
可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。  
有序性：有序性：即程序执行的顺序按照代码的先后顺序执行**  

加入volatile关键字时，会多出一个lock前缀指令：
lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  
   1)  它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成  
   2)  它会强制将对缓存的修改操作立即写入内存  
   3)  如果是写操作，它会导致其他CPU中对应的缓存行无效。    
   
synchronized则会阻止其它线程获取当前对象的监控锁，这样就使得当前对象中被synchronized关键字保护的代码块无法被其它线程访问，也就无法并发执行。
关于volatile和synchronized的区别：
1)  volatile本质是在告诉当前线程中的工作内存中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2)  volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3)  volatilebn能实现变量的修改可见性和有序性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性,有序性
4)  volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞

[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)
#   3. mysql 事务
事务是一个序列操作，其中的操作要么都执行，要么都不执行，它是一个不可分割的工作单位.事务有四大特性，被称作**ACID**。
### A(Atomicity) 原子性
事务就是一系列的操作，要么全部都执行，要都不执行。Mysql中通过使用 **回滚日志(undo log)** 来实现原子性。  

回滚日志并不能将数据库物理地恢复到执行语句或者事务之前的样子；它是逻辑日志，当回滚日志被使用时，它只会按照日志逻辑地将数据库中的修改撤销掉看，可以理解为，我们在事务中使用的每一条 INSERT 都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。

## C(Consistency) 一致性
一致性是指事务将数据库从一种一致性状态变为下一种一致性状态。事务开始前和结束后，数据库的完整性约束没有被破坏。例如工号带有唯一属性，如果经过一个修改工号的事务后，工号变的非唯一了，则表明一致性遭到了破坏。

## I(Isolation) 隔离性
隔离性要求每个读写事务对其他事务的操作对象能相互分离。MySQL支持4种隔离级别,随着事务隔离级别变得越来越严格，数据库对于并发执行事务的性能也逐渐下降。  
  
 1.  读未提交（READ UNCOMMITTED）
     任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交，会产生**脏读**。其实就是可以读到其他事务未提交的数据，但没有办法保证你读到的数据最终一定是提交后的数据，如果中间发生回滚，那就会出现脏数据问题。  
     事务A对某个数据进行修改，但是还未提交，如果事务B此时读取该数据就会读取到事务A中要修改的值，但是如果事务A要回滚，那么就会产生脏数据。  
     
 2.  读提交 （READ COMMITTED）
     读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。读提交就会产生**不可重复读问题**。不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的。流行的数据库都采用这种隔离级别，比如Oracle 和SQL Server,MySQL不是。  
     在同一事务中，事务的不同时刻同样的查询条件，查询出来的记录内容是不一样的，事务A的提交影响了事务B的查询结果。  
     
 3.  可重复读 （REPEATABLE READ）
     MySQL默认的隔离级别。而可重复读是指，事务不会读到其他事务对已有数据的修改，即使其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是会产生**幻读**问题。  
     
     **幻读**假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用
 4.  串行化 （SERIALIZABLE）
    串行化是4种事务隔离级别中隔离效果最好的，InnoDB 隐式地将全部的查询语句加上共享锁，解决了脏读、可重复读、幻读的问题,但是吞吐率最低。  
##  D(Durability) 持久性
一旦事务被提交，那么数据一定会被写入到数据库中并持久存储起来。MySQL使用**重做日志(redo log)** 实现事务的持久性，重做日志由两部分组成，一是内存中  的重做日志缓冲区，因为重做日志缓冲区在内存中，所以它是易失的，另一个就是在磁盘上的重做日志文件，它是持久的。    

当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，MySQL 会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘上.也就是说日志文件是比数据文件更早写到磁盘中的。  

[《包你懂系列》一文讲清楚 MySQL 事务隔离级别和实现原理，开发人员必备知识点](https://juejin.im/post/5e81fcbae51d4546bb6f33e8#heading-15)       
   
   
[『浅入深出』MySQL 中事务的实现](https://draveness.me/mysql-transaction/)
#   4. MySQL 中是如何实现事务隔离的
###   实现可重复读
为了实现可重复读，也就是事务在任意时刻读取的数据都是一样的，不会因为其他事务修改而发生变化。MySQL采用了**MVCC (多版本并发控制)** 的方式。  
数据库表中看到的一行记录可能实际上有多个版本，每个版本的记录除了有数据本身外，还要有一个表示版本的字段，通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取。  

###   并发写问题
并发写问题就是两个事务，对同一条数据做修改，数据最后应该是时间靠后的那个事务。更新之前要读数据，这个情况的读数据是当前版本的数据，也就是多版本中最新一次提交的那版。  
MySQL通过加行级锁来解决并发写问题。假设事务A执行 update 操作， update 的时候要对所修改的行加行锁，这个行锁会在提交之后才释放。而在事务A提交之前，事务B也想 update 这行数据，于是申请行锁，但是由于已经被事务A占有，事务B是申请不到的，此时，事务B就会一直处于等待状态，直到事务A提交，事务B才能继续执行。  
    
    
加锁的过程要分有索引和无索引两种情况。有索引的情况， MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。如果无索引,MySQL 会为这张表中所有行加行锁,在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行。  
### 解决幻读  
解决幻读用的也是锁，叫做间隙锁，MySQL 把行锁和间隙锁合并在一起，解决了并发写和幻读的问题，这个锁叫做 Next-Key锁。  
  
[《包你懂系列》一文讲清楚 MySQL 事务隔离级别和实现原理，开发人员必备知识点](https://juejin.im/post/5e81fcbae51d4546bb6f33e8#heading-15)  
#   5. 关于mysql索引，是否命中索引
